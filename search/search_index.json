{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Curriculum Curator","text":"<p>An educational content workflow orchestration tool designed to streamline the creation of comprehensive curriculum materials through Large Language Model (LLM) integration.</p> <ul> <li> <p>:material-playlist-plus: Workflow-driven content generation</p> <p>Create complete educational modules using configurable, automated workflows.</p> </li> <li> <p>:material-chat-processing: Prompt-centric approach</p> <p>All content is derived from well-designed prompts managed within the system.</p> </li> <li> <p>:material-check-all: Content validation and remediation</p> <p>Ensure quality through automated validation and remediation steps.</p> </li> <li> <p>:material-console: Interactive interfaces</p> <p>Build workflows and edit prompts with menu-driven interfaces.</p> </li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Prompt Registry: Manage a collection of prompts with metadata using YAML front matter</li> <li>LLM Integration: Support for multiple providers (Anthropic, OpenAI, Ollama, Groq, Gemini) via LiteLLM</li> <li>Content Transformation: Parse and structure raw LLM outputs in various formats</li> <li>Workflow Engine: Orchestrate the sequence of content generation, validation, and remediation steps</li> <li>Interactive Mode: Complete menu-driven interface for all operations</li> <li>Interactive Workflow Builder: Create and edit workflows through a menu-driven interface</li> <li>Interactive Prompt Editor: Create and edit prompts with templates and front matter validation</li> <li>Validation Framework: Ensure content quality and consistency through a suite of validators</li> <li>Multiple Output Formats: Generate HTML, PDF, DOCX, and presentation slide formats</li> <li>Cost Tracking: Monitor token usage and associated costs</li> <li>Session Management: Save, resume, and analyze workflow sessions</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install curriculum-curator\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Initialize a new project with example prompts\ncurator init\n\n# Run the minimal educational module workflow\ncurator run minimal_educational_module \\\n  --var course_title=\"Introduction to Python Programming\" \\\n  --var course_slug=\"intro-python\" \\\n  --var module_id=\"module1\" \\\n  --var num_modules=4 \\\n  --var \"learning_objectives=Understand Python basics;Write simple programs\"\n\n# Launch the interactive mode\ncurator interactive\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started: Installation and quick start guide</li> <li>User Guides: Detailed guides for using the various features</li> <li>Concepts: Learn about the core concepts and architecture</li> <li>API Reference: Detailed API documentation</li> <li>Development: Contributing guidelines and development process</li> </ul>"},{"location":"design-addendum/","title":"Configuration-Driven Workflow Design","text":"<p>This document describes the configuration-driven workflow design pattern implemented in Curriculum Curator.</p>"},{"location":"design-addendum/#overview","title":"Overview","text":"<p>The Curriculum Curator system uses a configuration-driven approach to defining workflows. In this pattern, the workflow logic and execution engine are separated from the workflow definitions, which are stored in external configuration files. This approach has several advantages:</p> <ol> <li>Flexibility: Workflows can be modified without changing code</li> <li>Reusability: Common steps can be reused across different workflows</li> <li>Shareability: Workflow definitions can be easily shared between users</li> <li>Version Control: Workflows can be versioned independently of the core code</li> <li>Extensibility: New step types can be added without breaking existing workflows</li> </ol>"},{"location":"design-addendum/#workflow-configuration-structure","title":"Workflow Configuration Structure","text":"<p>Workflows are defined in YAML files that specify the sequence of steps to be executed:</p> <pre><code>name: minimal_educational_module\ndescription: \"Generates a complete educational module with basic components\"\nsteps:\n  - name: course_overview\n    type: prompt\n    prompt: course/overview.txt\n    llm_model_alias: default_smart\n    output_format: raw\n    output_variable: course_overview\n\n  # Additional steps...\n\n  - name: generate_outputs\n    type: output\n    output_mapping:\n      course_overview: overview.md\n      remediated_lecture: lecture.md\n      worksheet: worksheet.md\n      assessment: assessment.md\n      instructor_materials: instructor_guide.md\n    output_dir: output/{course_slug}/{module_id}\n</code></pre> <p>Each workflow configuration includes: - name: Unique identifier for the workflow - description: Human-readable description of the workflow's purpose - steps: Array of step configurations, each with:   - name: Unique identifier for the step   - type: Step type (prompt, validation, remediation, output, etc.)   - step-specific parameters: Parameters specific to the step type</p>"},{"location":"design-addendum/#workflow-discovery","title":"Workflow Discovery","text":"<p>Workflows are discovered dynamically at runtime:</p> <ol> <li>The system looks for workflow configurations in predefined directories:</li> <li><code>examples/workflows/</code></li> <li> <p><code>workflows/</code></p> </li> <li> <p>All YAML files in these directories are loaded and indexed by name</p> </li> <li> <p>When a user requests a workflow by name, the system:</p> </li> <li>Searches for a matching workflow in the loaded configurations</li> <li>If found, loads the configuration and executes the workflow</li> <li>If not found, returns an error</li> </ol> <p>This approach allows users to add new workflows simply by adding new YAML files to the appropriate directory.</p>"},{"location":"design-addendum/#execution-engine","title":"Execution Engine","text":"<p>The workflow execution engine is responsible for:</p> <ol> <li>Loading the workflow configuration</li> <li>Creating step instances based on the step type</li> <li>Executing each step in sequence</li> <li>Managing the context shared between steps</li> <li>Handling errors and recovering from failures</li> <li>Persisting the state of the workflow for potential resumption</li> </ol> <p>The execution engine provides a uniform interface for all workflows, regardless of their specific steps or configurations.</p>"},{"location":"design-addendum/#context-sharing","title":"Context Sharing","text":"<p>Steps in a workflow share a common context dictionary that allows them to pass data to subsequent steps:</p> <ol> <li>The initial context contains variables provided by the user</li> <li>Each step can read values from the context and add new values to it</li> <li>Output variables from one step can be used as input for subsequent steps</li> <li>The final context contains all intermediate results and the final outputs</li> </ol> <p>This pattern allows complex workflows to be built from simple steps that each perform a specific task.</p>"},{"location":"design-addendum/#benefits-of-configuration-driven-workflows","title":"Benefits of Configuration-Driven Workflows","text":"<p>The configuration-driven approach provides several benefits:</p> <ol> <li>Separation of Concerns: Core logic remains stable while workflows can evolve</li> <li>Reduced Code Duplication: Common patterns are encapsulated in the engine</li> <li>Lower Barrier to Entry: Users can create workflows without coding</li> <li>Flexibility: Workflows can be adapted to different use cases without code changes</li> <li>Testing Simplicity: Workflows can be tested independently of the core code</li> </ol>"},{"location":"design-addendum/#implementation","title":"Implementation","text":"<p>The workflow system is implemented in the following components:</p> <ol> <li>WorkflowStep: Base class for all step types</li> <li>Workflow: Class that manages the execution of a sequence of steps</li> <li>Step Type Implementations: Specialized classes for each step type (PromptStep, ValidationStep, etc.)</li> <li>Workflow Configuration Loader: Utilities for loading workflow configurations from files</li> </ol> <p>This implementation allows for easy extension with new step types and workflow patterns.</p>"},{"location":"design-addendum/#future-enhancements","title":"Future Enhancements","text":"<p>The configuration-driven workflow system can be extended in several ways:</p> <ol> <li>Conditional Steps: Steps that execute based on conditions</li> <li>Loop Steps: Steps that repeat a sequence for each item in a collection</li> <li>Parallel Steps: Steps that execute in parallel for improved performance</li> <li>Custom Step Types: Support for user-defined step types</li> <li>Visual Workflow Editor: A graphical interface for building workflows</li> </ol>"},{"location":"design/","title":"Original Design","text":""},{"location":"design/#1-introduction","title":"1. Introduction","text":"<p>CurriculumCurator is an educational content workflow orchestration tool designed to streamline the creation of comprehensive curriculum materials through Large Language Model (LLM) integration. This document outlines the architectural design, component interactions, and implementation considerations for the system.</p>"},{"location":"design/#2-core-philosophy","title":"2. Core Philosophy","text":"<p>CurriculumCurator is designed around two fundamental principles:</p> <ol> <li>Prompt-centric Content Generation: All content is derived from well-designed prompts managed within the system.</li> <li>Workflow-driven Process: Content creation follows configurable, automated educational workflows.</li> </ol>"},{"location":"design/#3-system-architecture","title":"3. System Architecture","text":""},{"location":"design/#31-prompt-registry-filesystem-based-with-yaml-front-matter","title":"3.1 Prompt Registry (Filesystem-based with YAML Front Matter)","text":"<p>The foundation of the system is a managed collection of prompts stored directly as files with embedded metadata.</p>"},{"location":"design/#storage-structure","title":"Storage Structure","text":"<pre><code>prompts/\n  course/\n    overview.txt\n    faq.txt\n  module/\n    slides.txt\n    worksheet.txt\n  assessment/\n    mcq.txt\n    short-answer.txt\n    fill-blank.txt\n</code></pre>"},{"location":"design/#prompt-format","title":"Prompt Format","text":"<p>Each prompt file includes YAML Front Matter for metadata:</p> <pre><code>---\ndescription: Generates multiple-choice questions for a module.\nrequires:\n  - module_title\n  - key_concepts\n  - num_questions\ntags:\n  - assessment\n  - mcq\nversion: 1.1\n---\nGenerate {num_questions} multiple-choice questions about the key concepts ({key_concepts}) for the module titled \"{module_title}\".\nEach question should have one correct answer and three plausible distractors.\nFormat the output as Markdown list items.\n</code></pre>"},{"location":"design/#implementation","title":"Implementation","text":"<pre><code>import frontmatter\nfrom pathlib import Path\n\nclass PromptRegistry:\n    def __init__(self, base_path):\n        self.base_path = Path(base_path)\n        self.prompt_cache = {}\n\n    def get_prompt(self, prompt_path):\n        \"\"\"Get a prompt by its path relative to the base path.\"\"\"\n        if prompt_path in self.prompt_cache:\n            return self.prompt_cache[prompt_path]\n\n        full_path = self.base_path / prompt_path\n        if not full_path.exists():\n            raise FileNotFoundError(f\"Prompt not found: {prompt_path}\")\n\n        prompt_data = frontmatter.load(full_path)\n        self.prompt_cache[prompt_path] = {\n            \"content\": prompt_data.content,\n            \"metadata\": prompt_data.metadata\n        }\n\n        return self.prompt_cache[prompt_path]\n\n    def list_prompts(self, tag=None):\n        \"\"\"List all prompts, optionally filtered by tag.\"\"\"\n        prompts = []\n        for file_path in self.base_path.glob(\"**/*.txt\"):\n            relative_path = file_path.relative_to(self.base_path)\n            if tag is None:\n                prompts.append(str(relative_path))\n            else:\n                try:\n                    prompt_data = self.get_prompt(str(relative_path))\n                    if tag in prompt_data[\"metadata\"].get(\"tags\", []):\n                        prompts.append(str(relative_path))\n                except Exception:\n                    continue\n\n        return prompts\n</code></pre>"},{"location":"design/#32-llm-integration-layer-broker-based","title":"3.2 LLM Integration Layer (Broker-based)","text":"<p>A flexible interface for interacting with various LLM providers using LiteLLM as the broker.</p>"},{"location":"design/#configuration","title":"Configuration","text":"<pre><code>llm:\n  default_provider: \"ollama\"  # Fallback provider\n  providers:\n    anthropic:\n      api_key: \"env(ANTHROPIC_API_KEY)\"\n      default_model: \"claude-3-haiku\"\n      cost_per_1k_tokens:\n        input: 0.25\n        output: 0.75\n      models:\n        claude-3-haiku: {}\n        claude-3-opus:\n          cost_per_1k_tokens:\n            input: 15.00\n            output: 75.00\n\n    openai:\n      api_key: \"env(OPENAI_API_KEY)\"\n      default_model: \"gpt-3.5-turbo\"\n      cost_per_1k_tokens:\n        input: 0.50\n        output: 1.50\n      models:\n        gpt-3.5-turbo: {}\n        gpt-4-turbo:\n          cost_per_1k_tokens:\n            input: 10.00\n            output: 30.00\n\n    ollama:\n      base_url: \"http://localhost:11434\"\n      default_model: \"llama3\"\n      cost_per_1k_tokens:\n        input: 0.00\n        output: 0.00\n      models:\n        llama3: {}\n        mistral: {}\n\n    groq:\n      api_key: \"env(GROQ_API_KEY)\"\n      default_model: \"llama3-8b-8192\"\n      cost_per_1k_tokens:\n        input: 0.10\n        output: 0.30\n      models:\n        llama3-8b-8192: {}\n\n    gemini:\n      api_key: \"env(GOOGLE_API_KEY)\"\n      default_model: \"gemini-pro\"\n      cost_per_1k_tokens:\n        input: 0.50\n        output: 1.50\n      models:\n        gemini-pro: {}\n</code></pre>"},{"location":"design/#implementation_1","title":"Implementation","text":"<pre><code>import os\nimport time\nimport litellm\nfrom datetime import datetime\nimport backoff\nimport structlog\n\nlogger = structlog.get_logger()\n\nclass LLMRequestError(Exception):\n    \"\"\"Exception raised for errors in LLM requests.\"\"\"\n    pass\n\nclass LLMRequest:\n    def __init__(self, prompt, provider, model, workflow_id=None, step_name=None):\n        self.prompt = prompt\n        self.provider = provider\n        self.model = model\n        self.workflow_id = workflow_id\n        self.step_name = step_name\n        self.timestamp = datetime.now()\n        self.input_tokens = None\n        self.output_tokens = None\n        self.completion = None\n        self.duration = None\n        self.cost = None\n        self.status = \"pending\"\n        self.error = None\n\nclass LLMManager:\n    def __init__(self, config):\n        self.config = config\n        self.history = []\n        self.current_workflow_id = None\n        self.current_step_name = None\n\n        # Configure API keys from environment variables\n        for provider, provider_config in config[\"llm\"][\"providers\"].items():\n            api_key = provider_config.get(\"api_key\", \"\")\n            if api_key.startswith(\"env(\") and api_key.endswith(\")\"):\n                env_var = api_key[4:-1]\n                api_key = os.getenv(env_var, \"\")\n                if provider != \"ollama\" and not api_key:\n                    logger.warning(f\"Missing API key for {provider}\", env_var=env_var)\n\n    def _resolve_model_alias(self, model_alias=None):\n        \"\"\"Resolve model alias to provider and model.\"\"\"\n        if model_alias is None:\n            default_provider = self.config[\"llm\"][\"default_provider\"]\n            default_model = self.config[\"llm\"][\"providers\"][default_provider][\"default_model\"]\n            return default_provider, default_model\n\n        # Check if alias is in provider/model format\n        if \"/\" in model_alias:\n            provider, model = model_alias.split(\"/\", 1)\n            if (provider in self.config[\"llm\"][\"providers\"] and\n                model in self.config[\"llm\"][\"providers\"][provider][\"models\"]):\n                return provider, model\n\n        # Otherwise, assume it's a direct model reference and search for it\n        for provider, provider_config in self.config[\"llm\"][\"providers\"].items():\n            if model_alias in provider_config[\"models\"]:\n                return provider, model_alias\n\n        # Fall back to default if not found\n        default_provider = self.config[\"llm\"][\"default_provider\"]\n        default_model = self.config[\"llm\"][\"providers\"][default_provider][\"default_model\"]\n        logger.warning(\n            \"model_alias_not_found\", \n            model_alias=model_alias,\n            using_default=f\"{default_provider}/{default_model}\"\n        )\n        return default_provider, default_model\n\n    def _calculate_cost(self, request):\n        \"\"\"Calculate cost based on token counts and configured rates.\"\"\"\n        provider_config = self.config[\"llm\"][\"providers\"][request.provider]\n        model_config = provider_config[\"models\"].get(request.model, {})\n\n        # Get costs, checking model-specific, then provider default\n        input_cost = model_config.get(\"cost_per_1k_tokens\", {}).get(\n            \"input\", provider_config[\"cost_per_1k_tokens\"][\"input\"]\n        )\n        output_cost = model_config.get(\"cost_per_1k_tokens\", {}).get(\n            \"output\", provider_config[\"cost_per_1k_tokens\"][\"output\"]\n        )\n\n        # Calculate total cost\n        request.cost = (\n            (request.input_tokens / 1000) * input_cost +\n            (request.output_tokens / 1000) * output_cost\n        )\n        return request.cost\n\n    @backoff.on_exception(\n        backoff.expo,\n        (Exception),\n        max_tries=3,\n        jitter=backoff.full_jitter\n    )\n    async def generate(self, prompt, model_alias=None, **params):\n        \"\"\"Generate text using the specified model or defaults.\"\"\"\n        # Resolve provider and model from alias or defaults\n        provider, model = self._resolve_model_alias(model_alias)\n\n        # Create request object for tracking\n        request = LLMRequest(\n            prompt=prompt, \n            provider=provider, \n            model=model,\n            workflow_id=self.current_workflow_id,\n            step_name=self.current_step_name\n        )\n        self.history.append(request)\n\n        logger.info(\n            \"llm_request_started\",\n            provider=provider,\n            model=model,\n            workflow_id=self.current_workflow_id,\n            step_name=self.current_step_name\n        )\n\n        start_time = time.time()\n        try:\n            # Get provider-specific configuration\n            provider_config = self.config[\"llm\"][\"providers\"][provider]\n\n            # Configure API key\n            api_key = provider_config.get(\"api_key\", \"\")\n            if api_key.startswith(\"env(\") and api_key.endswith(\")\"):\n                env_var = api_key[4:-1]\n                api_key = os.getenv(env_var, \"\")\n\n            # Configure base URL if needed (for Ollama, etc.)\n            base_url = provider_config.get(\"base_url\", None)\n\n            # Use LiteLLM to make the actual request\n            response = await litellm.acompletion(\n                model=f\"{provider}/{model}\",\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n                api_key=api_key,\n                base_url=base_url,\n                **params\n            )\n\n            request.status = \"success\"\n            request.completion = response.choices[0].message.content\n            request.input_tokens = response.usage.prompt_tokens\n            request.output_tokens = response.usage.completion_tokens\n\n            logger.info(\n                \"llm_request_completed\",\n                provider=provider,\n                model=model,\n                input_tokens=request.input_tokens,\n                output_tokens=request.output_tokens,\n                workflow_id=self.current_workflow_id,\n                step_name=self.current_step_name\n            )\n\n        except Exception as e:\n            request.status = \"error\"\n            request.error = str(e)\n            logger.exception(\n                \"llm_request_failed\",\n                provider=provider,\n                model=model,\n                error=str(e),\n                workflow_id=self.current_workflow_id,\n                step_name=self.current_step_name\n            )\n            raise LLMRequestError(f\"LLM request failed: {e}\")\n        finally:\n            request.duration = time.time() - start_time\n            if request.input_tokens and request.output_tokens:\n                self._calculate_cost(request)\n\n        return request.completion\n\n    def generate_usage_report(self, workflow_id=None, step_name=None):\n        \"\"\"Generate a usage report for the specified workflow and/or step.\"\"\"\n        # Filter history by workflow_id and step_name if provided\n        requests = [r for r in self.history \n                if (workflow_id is None or r.workflow_id == workflow_id)\n                and (step_name is None or r.step_name == step_name)]\n\n        # Group by provider and model\n        by_model = {}\n        for r in requests:\n            key = f\"{r.provider}/{r.model}\"\n            if key not in by_model:\n                by_model[key] = {\n                    \"count\": 0,\n                    \"input_tokens\": 0,\n                    \"output_tokens\": 0,\n                    \"cost\": 0,\n                    \"errors\": 0,\n                    \"avg_duration\": 0,\n                }\n\n            entry = by_model[key]\n            entry[\"count\"] += 1\n            if r.status == \"error\":\n                entry[\"errors\"] += 1\n            if r.status == \"success\":\n                entry[\"input_tokens\"] += r.input_tokens or 0\n                entry[\"output_tokens\"] += r.output_tokens or 0\n                entry[\"cost\"] += r.cost or 0\n                entry[\"avg_duration\"] = (entry[\"avg_duration\"] * (entry[\"count\"] - 1) + r.duration) / entry[\"count\"]\n\n        # Calculate totals\n        totals = {\n            \"count\": sum(m[\"count\"] for m in by_model.values()),\n            \"input_tokens\": sum(m[\"input_tokens\"] for m in by_model.values()),\n            \"output_tokens\": sum(m[\"output_tokens\"] for m in by_model.values()),\n            \"cost\": sum(m[\"cost\"] for m in by_model.values()),\n            \"errors\": sum(m[\"errors\"] for m in by_model.values()),\n        }\n\n        return {\n            \"by_model\": by_model,\n            \"totals\": totals,\n            \"timestamp\": datetime.now(),\n            \"workflow_id\": workflow_id,\n            \"step_name\": step_name,\n        }\n</code></pre>"},{"location":"design/#33-content-transformation-layer","title":"3.3 Content Transformation Layer","text":"<p>Parses and structures raw LLM outputs.</p> <pre><code>import re\nimport json\nimport markdown\nfrom bs4 import BeautifulSoup\n\nclass ContentTransformer:\n    def __init__(self):\n        pass\n\n    def transform(self, raw_content, output_format, transformation_rules=None):\n        \"\"\"Transform raw LLM output into the desired format.\"\"\"\n        if output_format == \"raw\":\n            return raw_content\n\n        if output_format == \"list\":\n            return self._extract_list_items(raw_content)\n\n        if output_format == \"json\":\n            return self._extract_json(raw_content)\n\n        if output_format == \"html\":\n            return self._markdown_to_html(raw_content)\n\n        # Default to returning the raw content\n        return raw_content\n\n    def _extract_list_items(self, content):\n        \"\"\"Extract list items from markdown content.\"\"\"\n        items = []\n        for line in content.split('\\n'):\n            # Match Markdown list items (both - and * style)\n            match = re.match(r'^\\s*[-*]\\s+(.+)$', line)\n            if match:\n                items.append(match.group(1).strip())\n\n            # Match numbered list items\n            match = re.match(r'^\\s*\\d+\\.\\s+(.+)$', line)\n            if match:\n                items.append(match.group(1).strip())\n\n        return items\n\n    def _extract_json(self, content):\n        \"\"\"Extract JSON from the content.\"\"\"\n        # Find content between triple backticks and json\n        match = re.search(r'```(?:json)?\\n([\\s\\S]*?)\\n```', content)\n        if match:\n            try:\n                return json.loads(match.group(1))\n            except json.JSONDecodeError:\n                pass\n\n        # Try parsing the entire content as JSON\n        try:\n            return json.loads(content)\n        except json.JSONDecodeError:\n            pass\n\n        # Return empty dict if no valid JSON found\n        return {}\n\n    def _markdown_to_html(self, content):\n        \"\"\"Convert markdown to HTML.\"\"\"\n        return markdown.markdown(content)\n\n    def extract_sections(self, content, section_markers=None):\n        \"\"\"Extract sections from content based on markdown headings.\"\"\"\n        if section_markers is None:\n            # Default to extracting sections by headings\n            sections = {}\n            current_section = None\n            current_content = []\n\n            for line in content.split('\\n'):\n                heading_match = re.match(r'^(#{1,6})\\s+(.+)$', line)\n                if heading_match:\n                    # Save previous section if exists\n                    if current_section:\n                        sections[current_section] = '\\n'.join(current_content).strip()\n\n                    # Start new section\n                    current_section = heading_match.group(2).strip()\n                    current_content = []\n                else:\n                    if current_section:\n                        current_content.append(line)\n\n            # Save the last section\n            if current_section:\n                sections[current_section] = '\\n'.join(current_content).strip()\n\n            return sections\n        else:\n            # Use custom section markers\n            sections = {}\n            for marker in section_markers:\n                pattern = f\"### {re.escape(marker)}\\\\s*\\\\n([\\\\s\\\\S]*?)(?=### [^#]|$)\"\n                match = re.search(pattern, content)\n                if match:\n                    sections[marker] = match.group(1).strip()\n\n            return sections\n</code></pre>"},{"location":"design/#34-workflow-engine","title":"3.4 Workflow Engine","text":"<p>Orchestrates the sequence of content generation, validation, and remediation steps.</p> <pre><code>import uuid\nimport asyncio\nimport structlog\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = structlog.get_logger()\n\nclass WorkflowError(Exception):\n    \"\"\"Exception raised for errors in workflow execution.\"\"\"\n    pass\n\nclass WorkflowStep:\n    def __init__(self, name, config):\n        self.name = name\n        self.config = config\n\n    async def execute(self, context, prompt_registry, llm_manager, content_transformer):\n        \"\"\"Execute this workflow step.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement execute()\")\n\nclass PromptStep(WorkflowStep):\n    async def execute(self, context, prompt_registry, llm_manager, content_transformer):\n        \"\"\"Execute a prompt-based step.\"\"\"\n        # Get prompt\n        prompt_path = self.config.get(\"prompt\")\n        if not prompt_path:\n            raise WorkflowError(f\"Missing prompt path for step {self.name}\")\n\n        try:\n            prompt_data = prompt_registry.get_prompt(prompt_path)\n        except FileNotFoundError as e:\n            raise WorkflowError(f\"Failed to load prompt: {e}\")\n\n        # Check required variables\n        required_vars = prompt_data[\"metadata\"].get(\"requires\", [])\n        missing_vars = [var for var in required_vars if var not in context]\n        if missing_vars:\n            raise WorkflowError(\n                f\"Missing required variables for prompt {prompt_path}: {', '.join(missing_vars)}\"\n            )\n\n        # Fill in prompt template\n        try:\n            prompt_content = prompt_data[\"content\"]\n            filled_prompt = prompt_content.format(**context)\n        except KeyError as e:\n            raise WorkflowError(f\"Error formatting prompt: {e}\")\n\n        # Get LLM response\n        model_alias = self.config.get(\"llm_model_alias\")\n        try:\n            response = await llm_manager.generate(filled_prompt, model_alias)\n        except Exception as e:\n            raise WorkflowError(f\"LLM generation failed: {e}\")\n\n        # Transform content if requested\n        output_format = self.config.get(\"output_format\", \"raw\")\n        transformation_rules = self.config.get(\"transformation_rules\", {})\n\n        try:\n            transformed_content = content_transformer.transform(\n                response, output_format, transformation_rules\n            )\n        except Exception as e:\n            raise WorkflowError(f\"Content transformation failed: {e}\")\n\n        # Store in context under output_variable\n        output_variable = self.config.get(\"output_variable\")\n        if output_variable:\n            context[output_variable] = transformed_content\n\n        # Store usage information in context\n        usage_stats = llm_manager.generate_usage_report(\n            workflow_id=context.get(\"workflow_id\"),\n            step_name=self.name\n        )\n\n        context.setdefault(\"usage_stats\", {})\n        context[\"usage_stats\"][self.name] = usage_stats\n\n        return transformed_content\n\nclass ValidationStep(WorkflowStep):\n    async def execute(self, context, prompt_registry, llm_manager, content_transformer):\n        \"\"\"Execute a validation step.\"\"\"\n        # Implementation for validation steps\n        pass\n\nclass OutputStep(WorkflowStep):\n    async def execute(self, context, prompt_registry, llm_manager, content_transformer):\n        \"\"\"Execute an output generation step.\"\"\"\n        # Implementation for output generation (e.g., using Pandoc)\n        pass\n\nclass Workflow:\n    def __init__(self, config, prompt_registry, llm_manager, content_transformer):\n        self.config = config\n        self.prompt_registry = prompt_registry\n        self.llm_manager = llm_manager\n        self.content_transformer = content_transformer\n        self.session_dir = None\n\n    def _create_step(self, step_config):\n        \"\"\"Create a workflow step from configuration.\"\"\"\n        step_type = step_config.get(\"type\", \"prompt\")\n        step_name = step_config.get(\"name\")\n\n        if step_type == \"prompt\":\n            return PromptStep(step_name, step_config)\n        elif step_type == \"validation\":\n            return ValidationStep(step_name, step_config)\n        elif step_type == \"output\":\n            return OutputStep(step_name, step_config)\n        else:\n            raise WorkflowError(f\"Unknown step type: {step_type}\")\n\n    def _initialize_session(self, session_id=None):\n        \"\"\"Initialize a new session or load an existing one.\"\"\"\n        if session_id is None:\n            session_id = f\"{datetime.now().strftime('%Y%m%d-%H%M%S')}-{uuid.uuid4().hex[:8]}\"\n\n        # Create session directory\n        base_dir = Path(self.config.get(\"session_base_dir\", \".curriculum_curator/sessions\"))\n        session_dir = base_dir / session_id\n        session_dir.mkdir(parents=True, exist_ok=True)\n\n        self.session_dir = session_dir\n        return session_id\n\n    def _save_session_state(self, context):\n        \"\"\"Save the current session state to disk.\"\"\"\n        if not self.session_dir:\n            return\n\n        # Save config used\n        with open(self.session_dir / \"config.yaml\", \"w\") as f:\n            import yaml\n            yaml.dump(self.config, f)\n\n        # Save session state (exclude large content)\n        sanitized_context = {\n            k: v for k, v in context.items() \n            if isinstance(v, (str, int, float, bool, list, dict))\n            and not isinstance(v, str) or len(v) &lt; 10000\n        }\n\n        with open(self.session_dir / \"session.json\", \"w\") as f:\n            import json\n            json.dump(sanitized_context, f, default=str, indent=2)\n\n        # Append to prompt history\n        with open(self.session_dir / \"prompt_history.jsonl\", \"a\") as f:\n            for request in self.llm_manager.history:\n                if request.workflow_id == context.get(\"workflow_id\"):\n                    import json\n                    json_record = {\n                        \"timestamp\": request.timestamp.isoformat(),\n                        \"provider\": request.provider,\n                        \"model\": request.model,\n                        \"step_name\": request.step_name,\n                        \"status\": request.status,\n                        \"input_tokens\": request.input_tokens,\n                        \"output_tokens\": request.output_tokens,\n                        \"cost\": request.cost,\n                        \"duration\": request.duration,\n                        \"prompt\": request.prompt[:1000] + \"...\" if len(request.prompt) &gt; 1000 else request.prompt,\n                    }\n                    f.write(json.dumps(json_record) + \"\\n\")\n\n    async def execute(self, workflow_name, initial_context=None, session_id=None):\n        \"\"\"Execute the specified workflow.\"\"\"\n        # Get workflow configuration\n        workflow_config = self.config.get(\"workflows\", {}).get(workflow_name)\n        if not workflow_config:\n            raise WorkflowError(f\"Workflow not found: {workflow_name}\")\n\n        # Initialize context\n        context = initial_context or {}\n        context[\"workflow_name\"] = workflow_name\n        context[\"workflow_id\"] = session_id or str(uuid.uuid4())\n        context[\"start_time\"] = datetime.now()\n\n        # Initialize session\n        session_id = self._initialize_session(session_id)\n        context[\"session_id\"] = session_id\n\n        # Configure LLM manager with workflow context\n        self.llm_manager.current_workflow_id = context[\"workflow_id\"]\n\n        # Get workflow steps\n        step_configs = workflow_config.get(\"steps\", [])\n        if not step_configs:\n            raise WorkflowError(f\"No steps defined for workflow: {workflow_name}\")\n\n        # Execute steps\n        results = {}\n        try:\n            for i, step_config in enumerate(step_configs):\n                step = self._create_step(step_config)\n                context[\"current_step\"] = step.name\n                context[\"current_step_index\"] = i\n\n                logger.info(\n                    \"workflow_step_started\",\n                    workflow_name=workflow_name,\n                    workflow_id=context[\"workflow_id\"],\n                    step_name=step.name,\n                    step_index=i\n                )\n\n                self.llm_manager.current_step_name = step.name\n\n                try:\n                    result = await step.execute(\n                        context, \n                        self.prompt_registry,\n                        self.llm_manager,\n                        self.content_transformer\n                    )\n                    results[step.name] = result\n\n                    logger.info(\n                        \"workflow_step_completed\",\n                        workflow_name=workflow_name,\n                        workflow_id=context[\"workflow_id\"],\n                        step_name=step.name,\n                        step_index=i\n                    )\n                except Exception as e:\n                    logger.exception(\n                        \"workflow_step_failed\",\n                        workflow_name=workflow_name,\n                        workflow_id=context[\"workflow_id\"],\n                        step_name=step.name,\n                        step_index=i,\n                        error=str(e)\n                    )\n                    context[\"error\"] = str(e)\n                    context[\"failed_step\"] = step.name\n                    self._save_session_state(context)\n                    raise WorkflowError(f\"Step {step.name} failed: {e}\")\n\n                # Save session state after each step\n                self._save_session_state(context)\n\n        finally:\n            context[\"end_time\"] = datetime.now()\n            context[\"duration\"] = (context[\"end_time\"] - context[\"start_time\"]).total_seconds()\n\n            # Generate final usage report\n            context[\"final_usage_report\"] = self.llm_manager.generate_usage_report(\n                workflow_id=context[\"workflow_id\"]\n            )\n\n            # Save final session state\n            self._save_session_state(context)\n\n        return {\n            \"results\": results,\n            \"context\": context,\n            \"session_id\": session_id\n        }\n</code></pre>"},{"location":"design/#35-validation-framework","title":"3.5 Validation Framework","text":"<p>Ensures content quality and consistency through a suite of validators that can be applied to generated content.</p> <pre><code>import re\nfrom abc import ABC, abstractmethod\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nimport structlog\n\nlogger = structlog.get_logger()\n\nclass ValidationIssue:\n    def __init__(self, severity, message, location=None, suggestion=None):\n        self.severity = severity  # \"error\", \"warning\", \"info\"\n        self.message = message\n        self.location = location  # E.g., \"section_name\", \"line:42\"\n        self.suggestion = suggestion  # Optional suggestion for fixing\n\n    def __str__(self):\n        return f\"{self.severity.upper()}: {self.message}\"\n\nclass Validator(ABC):\n    def __init__(self, config):\n        self.config = config\n\n    @abstractmethod\n    async def validate(self, content, context=None):\n        \"\"\"Validate content and return a list of validation issues.\"\"\"\n        pass\n\nclass SimilarityValidator(Validator):\n    def __init__(self, config):\n        super().__init__(config)\n        self.threshold = config.get(\"threshold\", 0.8)\n\n    async def validate(self, content, context=None):\n        \"\"\"Check for content similarity across sections or files.\"\"\"\n        issues = []\n\n        if isinstance(content, dict):\n            # If content is a dictionary of sections\n            sections = list(content.keys())\n            texts = list(content.values())\n        elif isinstance(content, list):\n            # If content is a list of documents\n            sections = [f\"document_{i}\" for i in range(len(content))]\n            texts = content\n        else:\n            # Single document, nothing to compare\n            return []\n\n        if len(texts) &lt; 2:\n            return []\n\n        # Calculate similarity matrix\n        vectorizer = TfidfVectorizer(stop_words='english')\n        try:\n            tfidf_matrix = vectorizer.fit_transform(texts)\n            similarity_matrix = cosine_similarity(tfidf_matrix)\n        except Exception as e:\n            issues.append(ValidationIssue(\n                \"error\",\n                f\"Failed to calculate similarity: {e}\",\n                None\n            ))\n            return issues\n\n        # Check for similarities above threshold\n        for i in range(len(texts)):\n            for j in range(i+1, len(texts)):\n                similarity = similarity_matrix[i, j]\n                if similarity &gt; self.threshold:\n                    issues.append(ValidationIssue(\n                        \"warning\",\n                        f\"High similarity ({similarity:.2f}) between '{sections[i]}' and '{sections[j]}'\",\n                        f\"{sections[i]},{sections[j]}\",\n                        \"Consider merging or revising the content to reduce duplication.\"\n                    ))\n\n        return issues\n\nclass StructureValidator(Validator):\n    def __init__(self, config):\n        super().__init__(config)\n        self.required_sections = config.get(\"required_sections\", [])\n        self.min_sections = config.get(\"min_sections\", 0)\n        self.section_pattern = config.get(\"section_pattern\", r'^#{1,3}\\s+(.+))\n\n    async def validate(self, content, context=None):\n        \"\"\"Validate the structure of the content.\"\"\"\n        issues = []\n\n        # Extract sections using regex\n        sections = []\n        for line in content.split('\\n'):\n            match = re.match(self.section_pattern, line)\n            if match:\n                sections.append(match.group(1).strip())\n\n        # Check minimum number of sections\n        if len(sections) &lt; self.min_sections:\n            issues.append(ValidationIssue(\n                \"error\",\n                f\"Content has {len(sections)} sections, but at least {self.min_sections} are required\",\n                None,\n                \"Add more sections to fulfill the structural requirements.\"\n            ))\n\n        # Check required sections\n        for required_section in self.required_sections:\n            found = False\n            for section in sections:\n                if required_section.lower() in section.lower():\n                    found = True\n                    break\n\n            if not found:\n                issues.append(ValidationIssue(\n                    \"error\",\n                    f\"Required section '{required_section}' not found\",\n                    None,\n                    f\"Add a '{required_section}' section to the content.\"\n                ))\n\n        return issues\n\nclass ReadabilityValidator(Validator):\n    \"\"\"Validates content for readability metrics.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(config)\n        self.min_flesch_reading_ease = config.get(\"min_flesch_reading_ease\", 60)  # Higher is easier to read\n        self.max_avg_sentence_length = config.get(\"max_avg_sentence_length\", 25)\n\n    async def validate(self, content, context=None):\n        \"\"\"Check readability of content.\"\"\"\n        issues = []\n\n        # Split content into sentences (basic implementation)\n        sentences = re.split(r'[.!?]+\\s+', content)\n\n        # Calculate average sentence length\n        if sentences:\n            total_words = sum(len(re.findall(r'\\b\\w+\\b', sentence)) for sentence in sentences)\n            avg_sentence_length = total_words / len(sentences)\n\n            if avg_sentence_length &gt; self.max_avg_sentence_length:\n                issues.append(ValidationIssue(\n                    \"warning\",\n                    f\"Average sentence length ({avg_sentence_length:.1f} words) exceeds maximum ({self.max_avg_sentence_length})\",\n                    None,\n                    \"Consider breaking longer sentences into shorter ones for improved readability.\"\n                ))\n\n        # TODO: Implement Flesch Reading Ease calculation\n        # This would typically involve syllable counting which is more complex\n\n        return issues\n\nclass ValidationManager:\n    \"\"\"Manages and runs multiple validators on content.\n\n    This class coordinates the execution of multiple validation checks\n    on generated content, collecting and organizing the results.\n    \"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        self.validators = {}\n        self._initialize_validators()\n\n    def _initialize_validators(self):\n        \"\"\"Initialize validators from configuration.\"\"\"\n        validator_configs = self.config.get(\"validation\", {})\n\n        if \"similarity\" in validator_configs:\n            self.validators[\"similarity\"] = SimilarityValidator(validator_configs[\"similarity\"])\n\n        if \"structure\" in validator_configs:\n            self.validators[\"structure\"] = StructureValidator(validator_configs[\"structure\"])\n\n        if \"readability\" in validator_configs:\n            self.validators[\"readability\"] = ReadabilityValidator(validator_configs[\"readability\"])\n\n    async def validate(self, content, validator_names=None, context=None):\n        \"\"\"Run specified validators on content.\"\"\"\n        all_issues = []\n\n        # Determine which validators to run\n        if validator_names is None:\n            validators_to_run = self.validators.values()\n        else:\n            validators_to_run = [\n                self.validators[name] for name in validator_names \n                if name in self.validators\n            ]\n\n        # Run each validator\n        for validator in validators_to_run:\n            validator_name = type(validator).__name__\n            logger.info(\n                \"running_validator\",\n                validator=validator_name,\n                content_type=type(content).__name__,\n                content_length=len(content) if isinstance(content, str) else \"N/A\"\n            )\n\n            try:\n                issues = await validator.validate(content, context)\n                all_issues.extend(issues)\n\n                logger.info(\n                    \"validator_completed\",\n                    validator=validator_name,\n                    issues_found=len(issues)\n                )\n            except Exception as e:\n                logger.exception(\n                    \"validator_failed\",\n                    validator=validator_name,\n                    error=str(e)\n                )\n\n                all_issues.append(ValidationIssue(\n                    \"error\",\n                    f\"Validation failed: {str(e)}\",\n                    None,\n                    None\n                ))\n\n        return all_issues\n</code></pre>"},{"location":"design/#4-user-interfaces","title":"4. User Interfaces","text":"<p>CurriculumCurator provides multiple ways for users to interact with the system.</p>"},{"location":"design/#41-command-line-interface-cli","title":"4.1 Command Line Interface (CLI)","text":"<p>The CLI is implemented using Typer for command definition and argument parsing, combined with Rich for formatted terminal output and progress display. This combination provides a modern, user-friendly command-line experience with minimal dependencies.</p> <p>The primary interface for running workflows and managing prompts.</p> <pre><code>import asyncio\nimport sys\nimport yaml\nimport json\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport typer\nimport structlog\nfrom rich import print # Optional: Use rich for nicer printing if desired\n\n# Assuming CurriculumCurator is importable (adjust path if needed)\n# from curriculum_curator.core import CurriculumCurator\n# Placeholder for example:\nclass CurriculumCurator:\n    def __init__(self, config):\n        self.config = config\n        self.prompt_registry = self # Simplified for example\n        logger.info(\"CurriculumCurator Initialized (placeholder)\")\n\n    def list_prompts(self, tag=None):\n        logger.info(f\"Listing prompts (placeholder)\", tag=tag)\n        # Replace with actual logic from PromptRegistry\n        if tag:\n            return [f\"prompt_with_{tag}.txt\"]\n        return [\"course/overview.txt\", \"module/slides.txt\", f\"prompt_with_some_tag.txt\"]\n\n    async def run_workflow(self, workflow_name, variables, session_id=None):\n        logger.info(f\"Running workflow (placeholder)\", workflow=workflow_name, vars=variables, session=session_id)\n        # Replace with actual async WorkflowEngine logic\n        await asyncio.sleep(0.1) # Simulate async work\n        return {\n            \"results\": {\"output_files\": {\"html\": f\"output/{session_id or 'new_session'}/content.html\"}},\n            \"session_id\": session_id or \"new_session_123\",\n            \"context\": {\n                \"final_usage_report\": {\n                    \"by_model\": {\"ollama/llama3\": {\"count\": 1, \"input_tokens\": 100, \"output_tokens\": 200, \"cost\": 0.0, \"errors\": 0}},\n                    \"totals\": {\"count\": 1, \"input_tokens\": 100, \"output_tokens\": 200, \"cost\": 0.0, \"errors\": 0}\n                }\n            }\n        }\n\n    async def resume_workflow(self, session_id, from_step=None):\n        logger.info(f\"Resuming workflow (placeholder)\", session=session_id, from_step=from_step)\n        # Replace with actual async WorkflowEngine logic\n        await asyncio.sleep(0.1) # Simulate async work\n        return {\n             \"results\": {\"output_files\": {\"pdf\": f\"output/{session_id}/content.pdf\"}},\n             \"session_id\": session_id,\n             \"context\": {\"final_usage_report\": {}} # Simplified\n         }\n# End Placeholder\n\nlogger = structlog.get_logger() # Assuming structlog is configured elsewhere\n\n# Create the Typer app\napp = typer.Typer(help=\"CurriculumCurator CLI - Orchestrate educational content workflows.\")\n\n# --- Helper Functions ---\n\ndef load_config(config_path: Path = typer.Option(\"config.yaml\", \"--config\", \"-c\", help=\"Path to configuration file.\")):\n    \"\"\"Loads configuration from YAML file. (Executed before commands needing it if used as dependency)\"\"\"\n    try:\n        with open(config_path, \"r\") as f:\n            return yaml.safe_load(f)\n    except FileNotFoundError:\n        print(f\"[bold red]Error:[/bold red] Configuration file not found at {config_path}\")\n        raise typer.Exit(code=1)\n    except Exception as e:\n        print(f\"[bold red]Error:[/bold red] Failed to load or parse configuration file {config_path}: {e}\")\n        raise typer.Exit(code=1)\n\ndef parse_vars(var_list: Optional[List[str]] = typer.Option(None, \"--var\", \"-v\", help=\"Variables in key=value format. Can be used multiple times.\")) -&gt; dict:\n    \"\"\"Parses the --var options into a dictionary.\"\"\"\n    variables = {}\n    if var_list:\n        for var in var_list:\n            if \"=\" in var:\n                key, value = var.split(\"=\", 1)\n                variables[key] = value\n            else:\n                print(f\"[yellow]Warning:[/yellow] Ignoring improperly formatted variable: {var}\")\n    return variables\n\ndef _print_result(result: dict, output_json: bool):\n    \"\"\"Helper to print workflow results.\"\"\"\n    if output_json:\n        # Output JSON result\n        print(json.dumps(result, indent=2, default=str))\n    else:\n        # Print summary using Rich\n        print(f\"[green]Workflow completed successfully.[/green]\")\n        print(f\"Session ID: [bold cyan]{result['session_id']}[/bold cyan]\")\n\n        output_files = result.get(\"results\", {}).get(\"output_files\", {})\n        if output_files:\n            print(\"\\n[bold]Output files:[/bold]\")\n            for format_name, path in output_files.items():\n                print(f\"  {format_name}: {path}\")\n\n        # Print usage statistics\n        usage = result.get(\"context\", {}).get(\"final_usage_report\", {})\n        if usage:\n            print(\"\\n[bold]Token Usage Summary:[/bold]\")\n            for model, stats in usage.get(\"by_model\", {}).items():\n                print(f\"  [yellow]{model}[/yellow]:\")\n                print(f\"    Requests: {stats['count']}\")\n                print(f\"    Input tokens: {stats['input_tokens']}\")\n                print(f\"    Output tokens: {stats['output_tokens']}\")\n                print(f\"    Cost: ${stats['cost']:.4f}\") # Requires cost calculation implementation\n\n            totals = usage.get(\"totals\", {})\n            if totals:\n                print(\"\\n  [bold]Total:[/bold]\")\n                print(f\"    Requests: {totals.get('count', 0)}\")\n                print(f\"    Input tokens: {totals.get('input_tokens', 0)}\")\n                print(f\"    Output tokens: {totals.get('output_tokens', 0)}\")\n                print(f\"    Cost: ${totals.get('cost', 0):.4f}\") # Requires cost calculation implementation\n\n\n# --- Typer Commands ---\n\n@app.command()\ndef run(\n    workflow: str = typer.Argument(..., help=\"Name of the workflow to run.\"),\n    var: Optional[List[str]] = typer.Option(None, \"--var\", \"-v\", help=\"Variables in key=value format. Can be used multiple times.\"),\n    session_id: Optional[str] = typer.Option(None, help=\"Specify a session ID to use or resume.\"),\n    config_path: Path = typer.Option(\"config.yaml\", \"--config\", \"-c\", help=\"Path to configuration file.\"),\n    output_json: bool = typer.Option(False, \"--output-json\", \"-j\", help=\"Output result as JSON.\")\n):\n    \"\"\"\n    Run a specified workflow.\n    \"\"\"\n    config = load_config(config_path)\n    variables = parse_vars(var)\n    curator = CurriculumCurator(config) # Assuming initialization with config\n    try:\n        print(f\"Running workflow '{workflow}'...\")\n        result = asyncio.run(curator.run_workflow(workflow, variables, session_id))\n        _print_result(result, output_json)\n    except Exception as e: # Replace with more specific exceptions later\n        logger.exception(\"workflow_failed\", error=str(e))\n        print(f\"[bold red]Error running workflow '{workflow}':[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n@app.command(name=\"list-workflows\")\ndef list_workflows_command(\n    config_path: Path = typer.Option(\"config.yaml\", \"--config\", \"-c\", help=\"Path to configuration file.\")\n):\n    \"\"\"\n    List available workflows defined in the configuration file.\n    \"\"\"\n    config = load_config(config_path)\n    workflows = config.get(\"workflows\", {})\n    if not workflows:\n        print(\"[yellow]No workflows found in configuration.[/yellow]\")\n        return\n\n    print(\"[bold]Available workflows:[/bold]\")\n    for name, workflow_config in workflows.items():\n        description = workflow_config.get(\"description\", \"[i]No description[/i]\")\n        print(f\"  [cyan]{name}[/cyan]: {description}\")\n\n@app.command(name=\"list-prompts\")\ndef list_prompts_command(\n    tag: Optional[str] = typer.Option(None, \"--tag\", \"-t\", help=\"Filter prompts by tag specified in YAML front matter.\"),\n    config_path: Path = typer.Option(\"config.yaml\", \"--config\", \"-c\", help=\"Path to configuration file.\")\n):\n    \"\"\"\n    List available prompts, optionally filtering by tag.\n    \"\"\"\n    config = load_config(config_path)\n    curator = CurriculumCurator(config) # Assuming initialization needed for registry path\n    try:\n        # Assuming curator object has access to prompt_registry\n        prompts = curator.prompt_registry.list_prompts(tag)\n        if not prompts:\n            print(\"[yellow]No prompts found.[/yellow]\" + (f\" matching tag '{tag}'.\" if tag else \".\"))\n            return\n\n        print(\"\\n[bold]Available prompts\" + (f\" matching tag '{tag}'\" if tag else \"\") + \":[/bold]\")\n        for prompt_path in prompts:\n            print(f\"  {prompt_path}\")\n\n    except Exception as e: # Replace with more specific exceptions later\n        logger.exception(\"list_prompts_failed\", error=str(e))\n        print(f\"[bold red]Error listing prompts:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n@app.command()\ndef resume(\n    session_id: str = typer.Argument(..., help=\"The Session ID of the workflow to resume.\"),\n    from_step: Optional[str] = typer.Option(None, help=\"Specific step name to resume from (implementation needed).\"),\n    config_path: Path = typer.Option(\"config.yaml\", \"--config\", \"-c\", help=\"Path to configuration file.\"),\n    output_json: bool = typer.Option(False, \"--output-json\", \"-j\", help=\"Output result as JSON.\")\n):\n    \"\"\"\n    Resume a previously interrupted workflow session (basic placeholder).\n    \"\"\"\n    config = load_config(config_path)\n    curator = CurriculumCurator(config) # Assuming initialization with config\n    try:\n        print(f\"Resuming workflow session '{session_id}'...\")\n        result = asyncio.run(curator.resume_workflow(session_id, from_step))\n        print(\"[green]Workflow resumed successfully.[/green]\") # Simplified message\n        _print_result(result, output_json)\n    except Exception as e: # Replace with more specific exceptions later\n        logger.exception(\"resume_workflow_failed\", error=str(e))\n        print(f\"[bold red]Error resuming workflow session '{session_id}':[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n\n# --- Entry Point ---\n\nif __name__ == \"__main__\":\n    # Configure logging (basic example)\n    structlog.configure(\n        processors=[\n            structlog.processors.add_log_level,\n            structlog.processors.StackInfoRenderer(),\n            structlog.dev.ConsoleRenderer(),\n        ],\n        logger_factory=structlog.stdlib.LoggerFactory(),\n        cache_logger_on_first_use=True,\n    )\n    # Run the Typer app\n    app()\n</code></pre>"},{"location":"design/#42-python-api","title":"4.2 Python API","text":"<p>For programmatic use and integration into other Python applications.</p> <pre><code># Example usage of the Python API\nfrom curriculum_curator import CurriculumCurator\n\nasync def generate_course_materials():\n    # Initialize with configuration\n    curator = CurriculumCurator(config_path=\"config.yaml\")\n\n    # Define course parameters\n    course_params = {\n        \"course_title\": \"Introduction to Python Programming\",\n        \"learning_objectives\": [\n            \"Understand basic Python syntax\",\n            \"Write and execute simple programs\",\n            \"Use control structures and functions\"\n        ],\n        \"num_modules\": 4\n    }\n\n    # Run the course generation workflow\n    result = await curator.run_workflow(\"standard_course\", course_params)\n\n    # Process the results\n    print(f\"Course materials generated successfully.\")\n    print(f\"Output files:\")\n    for format, path in result.get(\"results\", {}).get(\"output_files\", {}).items():\n        print(f\"  {format}: {path}\")\n\n    # Get token usage info\n    usage = result.get(\"context\", {}).get(\"final_usage_report\", {})\n    print(f\"Total cost: ${usage.get('totals', {}).get('cost', 0):.4f}\")\n\n    return result\n\n# Run the example\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(generate_course_materials())\n</code></pre>"},{"location":"design/#43-future-user-interfaces","title":"4.3 Future User Interfaces","text":""},{"location":"design/#431-terminal-user-interface-tui","title":"4.3.1 Terminal User Interface (TUI)","text":"<p>A planned interactive terminal interface using libraries like textual or rich.</p>"},{"location":"design/#432-web-interface","title":"4.3.2 Web Interface","text":""},{"location":"design/#web-interface","title":"Web Interface","text":"<p>A web-based dashboard for monitoring workflows and managing content, built with:</p> <ul> <li>FastHTML: Server-side rendered (SSR) Python web framework based on Starlette</li> <li>HTMX: Handles dynamic content updates without complex JavaScript</li> <li>Pico CSS: Lightweight CSS framework included with FastHTML by default</li> </ul> <p>This stack allows maintaining Python as the single programming language while still delivering a responsive, interactive user experience. The server-side rendering approach simplifies deployment and improves initial page load performance.</p> <p>Example implementation sketch:</p> <pre><code>from fasthtml.common import *\n\napp, rt = fast_app()\n\n@rt(\"/\")\ndef get():\n    \"\"\"Render the main dashboard.\"\"\"\n    return Titled(\"CurriculumCurator Dashboard\", \n        Div(id=\"workflows\"),\n        Div(id=\"usage-stats\")\n    )\n\n@rt(\"/workflows\")\ndef get():\n    \"\"\"List available workflows.\"\"\"\n    curator = get_curator_instance()\n    workflows = curator.list_workflows()\n\n    workflow_list = Ul()\n    for name, workflow in workflows.items():\n        description = workflow.get(\"description\", \"No description\")\n        workflow_list.append(Li(\n            A(name, href=f\"/workflows/{name}\"),\n            P(description)\n        ))\n\n    return Titled(\"Available Workflows\", workflow_list)\n\n@rt(\"/workflow/{name}\")\ndef get(name: str):\n    \"\"\"Display workflow details and execution options.\"\"\"\n    curator = get_curator_instance()\n    workflow = curator.get_workflow(name)\n\n    form = Form(\n        H2(\"Run Workflow\"),\n        Input(id=\"workflow_name\", name=\"workflow_name\", value=name, type=\"hidden\"),\n        Input(id=\"course_title\", name=\"course_title\", placeholder=\"Course Title\"),\n        Textarea(id=\"learning_objectives\", name=\"learning_objectives\", \n                placeholder=\"Learning Objectives (one per line)\"),\n        Button(\"Start Workflow\", type=\"submit\"),\n        hx_post=\"/api/run-workflow\",\n        hx_target=\"#execution-results\"\n    )\n\n    return Titled(f\"Workflow: {name}\", \n        Div(workflow.get(\"description\", \"No description\")),\n        form,\n        Div(id=\"execution-results\")\n    )\n\n@rt(\"/api/run-workflow\")\ndef post(workflow_name: str, course_title: str, learning_objectives: str):\n    \"\"\"Execute a workflow with the provided parameters.\"\"\"\n    curator = get_curator_instance()\n\n    # Parse learning objectives into a list\n    objectives = [obj.strip() for obj in learning_objectives.split(\"\\n\") if obj.strip()]\n\n    # Set up the context with the form values\n    context = {\n        \"course_title\": course_title,\n        \"learning_objectives\": objectives\n    }\n\n    # Run the workflow asynchronously\n    session_id = curator.start_workflow(workflow_name, context)\n\n    # Return a message with the session ID and a refresh trigger\n    return Div(\n        H3(\"Workflow Started\"),\n        P(f\"Session ID: {session_id}\"),\n        P(\"Results will appear here as they become available.\"),\n        hx_trigger=\"load delay:2s\",\n        hx_get=f\"/api/workflow-status/{session_id}\",\n        hx_target=\"#execution-results\"\n    )\n\n@rt(\"/api/workflow-status/{session_id}\")\ndef get(session_id: str):\n    \"\"\"Get the status of a workflow execution.\"\"\"\n    curator = get_curator_instance()\n    status = curator.get_workflow_status(session_id)\n\n    if status[\"completed\"]:\n        # Show completion details\n        results = Div(\n            H3(\"Workflow Completed\"),\n            P(f\"Started: {status['start_time']}\"),\n            P(f\"Completed: {status['end_time']}\"),\n            P(f\"Duration: {status['duration']} seconds\"),\n            H4(\"Generated Files\"),\n            Ul(*[Li(A(format, href=path)) for format, path in status.get(\"output_files\", {}).items()]),\n            H4(\"Usage Statistics\"),\n            P(f\"Total tokens: {status['usage']['total_tokens']}\"),\n            P(f\"Total cost: ${status['usage']['cost']:.4f}\")\n        )\n        return results\n    else:\n        # Show progress and trigger another refresh\n        progress = Div(\n            H3(\"Workflow In Progress\"),\n            P(f\"Current step: {status.get('current_step', 'Initializing')}\"),\n            P(f\"Progress: {status.get('progress', 0)}%\"),\n            hx_trigger=\"load delay:3s\",\n            hx_get=f\"/api/workflow-status/{session_id}\",\n            hx_target=\"#execution-results\"\n        )\n        return progress\n\nserve()\n\n## 5. Error Handling Strategy\n\nCurriculumCurator implements a comprehensive error handling approach to ensure robustness in dealing with various failure scenarios.\n\n### 5.1 Exception Hierarchy\n\n```python\n# Core exceptions\nclass CurriculumCuratorError(Exception):\n    \"\"\"Base exception for all curriculum curator errors.\"\"\"\n    pass\n\n# Component-specific exceptions\nclass PromptError(CurriculumCuratorError):\n    \"\"\"Exceptions related to prompt loading and rendering.\"\"\"\n    pass\n\nclass LLMRequestError(CurriculumCuratorError):\n    \"\"\"Exceptions related to LLM API requests.\"\"\"\n    pass\n\nclass WorkflowError(CurriculumCuratorError):\n    \"\"\"Exceptions related to workflow execution.\"\"\"\n    pass\n\nclass ValidationError(CurriculumCuratorError):\n    \"\"\"Exceptions related to content validation.\"\"\"\n    pass\n\nclass RemediationError(CurriculumCuratorError):\n    \"\"\"Exceptions related to content remediation.\"\"\"\n    pass\n\nclass OutputError(CurriculumCuratorError):\n    \"\"\"Exceptions related to output production.\"\"\"\n    pass\n</code></pre>"},{"location":"design/#52-retry-mechanisms","title":"5.2 Retry Mechanisms","text":"<p>CurriculumCurator uses the <code>backoff</code> library for intelligent retry of operations that might fail temporarily:</p> <pre><code>import backoff\n\n@backoff.on_exception(\n    backoff.expo,\n    (LLMRequestError, ConnectionError),\n    max_tries=3,\n    jitter=backoff.full_jitter\n)\nasync def get_llm_response(prompt, model_alias, **params):\n    \"\"\"Get LLM response with exponential backoff retries.\"\"\"\n    # Implementation\n</code></pre>"},{"location":"design/#53-graceful-degradation","title":"5.3 Graceful Degradation","text":"<p>The system is designed to continue operation even when some components fail:</p> <ol> <li>LLM Provider Fallbacks: If the primary LLM provider fails, the system can fall back to alternative providers.</li> <li>Validation Continuation: If a validator fails, the validation process continues with other validators.</li> <li>Remediation Skipping: If remediation fails, the original content is used instead.</li> <li>Output Format Alternatives: If a particular output format conversion fails, other formats are still generated.</li> </ol>"},{"location":"design/#54-structured-logging","title":"5.4 Structured Logging","text":"<p>All components use structured logging to provide detailed context for debugging:</p> <pre><code>import structlog\n\nlogger = structlog.get_logger()\n\n# Examples of structured logging\nlogger.info(\n    \"workflow_step_started\",\n    workflow_id=\"abc123\",\n    step_name=\"generate_overview\",\n    attempt=2\n)\n\nlogger.error(\n    \"llm_request_failed\",\n    error=\"Rate limit exceeded\",\n    provider=\"openai\",\n    model=\"gpt-4\"\n)\n</code></pre>"},{"location":"design/#55-user-feedback","title":"5.5 User Feedback","text":"<p>Errors are communicated to users with clear, actionable information:</p> <ol> <li>CLI Feedback: Error messages with suggested actions.</li> <li>API Error Responses: Structured error objects with error codes and descriptions.</li> <li>Interactive UI: Visual indicators of errors with resolution options.</li> </ol>"},{"location":"design/#6-data-persistence-strategy","title":"6. Data Persistence Strategy","text":"<p>CurriculumCurator uses a lightweight, file-based approach to data persistence.</p>"},{"location":"design/#61-session-management","title":"6.1 Session Management","text":"<p>Each workflow execution creates a session with the following structure:</p> <pre><code>.curriculum_curator/\n  sessions/\n    20240405-123456/\n      config.yaml      # Copy of configuration used\n      session.json     # Record of steps executed and their status\n      prompt_history.jsonl  # Record of prompts sent and responses\n      context.json     # Context variables at the end of execution\n      usage_report.json  # Token usage and cost information\n</code></pre> <p>This approach offers several benefits: - No database dependency - Easy inspection and debugging - Simple session resumption - Historical record for billing and analysis</p>"},{"location":"design/#62-output-management","title":"6.2 Output Management","text":"<p>Generated content is stored in an output directory structure:</p> <pre><code>output/\n  20240405-123456/     # Timestamp-based subdirectory\n    content.md         # Intermediate Markdown content\n    metadata.yaml      # Content metadata\n    content.html       # HTML output\n    content.pdf        # PDF output\n    content.docx       # DOCX output\n    slides.html        # Presentation slides\n</code></pre> <p>This approach allows: - Clean organization of outputs - Multiple format versions of the same content - Preservation of intermediate formats - Easy sharing of output directories</p>"},{"location":"design/#63-persistence-interfaces","title":"6.3 Persistence Interfaces","text":"<pre><code>class PersistenceManager:\n    \"\"\"Manages data persistence for curriculum curator.\"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        self.base_dir = Path(config.get(\"persistence_dir\", \".curriculum_curator\"))\n        self.sessions_dir = self.base_dir / \"sessions\"\n        self.sessions_dir.mkdir(parents=True, exist_ok=True)\n\n    def create_session(self, session_id=None):\n        \"\"\"Create a new session directory and return the session ID.\"\"\"\n        if session_id is None:\n            from datetime import datetime\n            import uuid\n            session_id = f\"{datetime.now().strftime('%Y%m%d-%H%M%S')}-{uuid.uuid4().hex[:8]}\"\n\n        session_dir = self.sessions_dir / session_id\n        session_dir.mkdir(exist_ok=True)\n\n        return session_id, session_dir\n\n    def save_session_state(self, session_id, context):\n        \"\"\"Save the current session state to disk.\"\"\"\n        session_dir = self.sessions_dir / session_id\n\n        # Save context (excluding large content)\n        sanitized_context = {\n            k: v for k, v in context.items() \n            if isinstance(v, (str, int, float, bool, list, dict))\n            and not isinstance(v, str) or len(v) &lt; 10000\n        }\n\n        with open(session_dir / \"context.json\", \"w\") as f:\n            import json\n            json.dump(sanitized_context, f, default=str, indent=2)\n\n    def save_config(self, session_id, config):\n        \"\"\"Save the configuration used for this session.\"\"\"\n        session_dir = self.sessions_dir / session_id\n\n        with open(session_dir / \"config.yaml\", \"w\") as f:\n            import yaml\n            yaml.dump(config, f)\n\n    def append_prompt_history(self, session_id, request):\n        \"\"\"Append a prompt request to the prompt history.\"\"\"\n        session_dir = self.sessions_dir / session_id\n\n        with open(session_dir / \"prompt_history.jsonl\", \"a\") as f:\n            import json\n            json_record = {\n                \"timestamp\": request.timestamp.isoformat(),\n                \"provider\": request.provider,\n                \"model\": request.model,\n                \"step_name\": request.step_name,\n                \"status\": request.status,\n                \"input_tokens\": request.input_tokens,\n                \"output_tokens\": request.output_tokens,\n                \"cost\": request.cost,\n                \"duration\": request.duration,\n                \"prompt\": request.prompt[:1000] + \"...\" if len(request.prompt) &gt; 1000 else request.prompt,\n            }\n            f.write(json.dumps(json_record) + \"\\n\")\n\n    def save_usage_report(self, session_id, usage_report):\n        \"\"\"Save the usage report for this session.\"\"\"\n        session_dir = self.sessions_dir / session_id\n\n        with open(session_dir / \"usage_report.json\", \"w\") as f:\n            import json\n            json.dump(usage_report, f, default=str, indent=2)\n\n    def load_session(self, session_id):\n        \"\"\"Load a session state from disk.\"\"\"\n        session_dir = self.sessions_dir / session_id\n\n        if not session_dir.exists():\n            raise ValueError(f\"Session not found: {session_id}\")\n\n        # Load context\n        context = {}\n        context_file = session_dir / \"context.json\"\n        if context_file.exists():\n            with open(context_file, \"r\") as f:\n                import json\n                context = json.load(f)\n\n        # Load config\n        config = None\n        config_file = session_dir / \"config.yaml\"\n        if config_file.exists():\n            with open(config_file, \"r\") as f:\n                import yaml\n                config = yaml.safe_load(f)\n\n        return {\n            \"session_id\": session_id,\n            \"context\": context,\n            \"config\": config\n        }\n\n    def list_sessions(self):\n        \"\"\"List all available sessions.\"\"\"\n        return [d.name for d in self.sessions_dir.iterdir() if d.is_dir()]\n</code></pre>"},{"location":"design/#7-workflow-process","title":"7. Workflow Process","text":"<p>The educational content workflow follows a structured sequence that can be customized via configuration.</p>"},{"location":"design/#71-standard-course-workflow","title":"7.1 Standard Course Workflow","text":"<p>A typical course generation workflow includes the following steps:</p> <ol> <li>Course Planning:</li> <li>Define course topic and learning objectives</li> <li>Establish module structure</li> <li> <p>Set the target audience and difficulty level</p> </li> <li> <p>Content Generation:</p> </li> <li>Generate course overview document</li> <li>Create slide decks for each module</li> <li>Develop worksheets for hands-on activities</li> <li> <p>Compile FAQs for common questions</p> </li> <li> <p>Assessment Creation:</p> </li> <li>Design multiple-choice questions</li> <li>Craft short answer questions</li> <li> <p>Develop fill-in-the-blank exercises</p> </li> <li> <p>Validation &amp; Remediation:</p> </li> <li>Check content similarity across modules</li> <li>Validate structure against requirements</li> <li>Assess educational quality and readability</li> <li> <p>Apply automated fixes for identified issues</p> </li> <li> <p>Output Production:</p> </li> <li>Convert to HTML for web viewing</li> <li>Generate PDFs for printing</li> <li>Create DOCX for editing</li> <li>Build slide presentations</li> </ol>"},{"location":"design/#72-example-workflow-configuration","title":"7.2 Example Workflow Configuration","text":"<pre><code>workflows:\n  standard_course:\n    description: \"Standard course generation workflow\"\n    steps:\n      - name: generate_course_overview\n        type: prompt\n        prompt: course/overview.txt\n        llm_model_alias: default_smart\n        output_variable: course_overview_md\n        output_format: raw\n\n      - name: generate_module_outlines\n        type: prompt\n        prompt: module/outline.txt\n        llm_model_alias: default_smart\n        output_variable: module_outlines_json\n        output_format: json\n\n      - name: generate_module_slides\n        type: loop\n        loop_variable: module\n        loop_source: module_outlines_json\n        steps:\n          - name: generate_slides\n            type: prompt\n            prompt: module/slides.txt\n            llm_model_alias: default_smart\n            output_variable: \"module_slides_${module.id}\"\n            output_format: raw\n\n      - name: validate_content\n        type: validation\n        validators: [similarity, structure, readability]\n        targets: [course_overview_md, \"module_slides_*\"]\n\n      - name: remediate_content\n        type: remediation\n        remediators: [content_merger, sentence_splitter]\n        targets: [course_overview_md, \"module_slides_*\"]\n\n      - name: generate_output\n        type: output\n        formats: [html, pdf, docx, slides]\n        content_variable: course_overview_md\n        metadata:\n          title: \"${course_title}\"\n          author: \"CurriculumCurator\"\n          date: \"${current_date}\"\n</code></pre>"},{"location":"design/#73-custom-workflow-steps","title":"7.3 Custom Workflow Steps","text":"<p>The workflow engine supports several types of steps:</p> <ol> <li>Prompt Steps: Generate content using LLM prompts</li> <li>Validation Steps: Check content quality and consistency</li> <li>Remediation Steps: Fix issues identified during validation</li> <li>Output Steps: Convert content to desired formats</li> <li>Loop Steps: Repeat a sequence of steps for each item in a collection</li> <li>Conditional Steps: Execute steps based on conditions</li> <li>Custom Steps: User-defined steps for specific needs</li> </ol>"},{"location":"design/#8-implementation-approach","title":"8. Implementation Approach","text":""},{"location":"design/#81-project-structure","title":"8.1 Project Structure","text":"<pre><code>curriculum_curator/\n  __init__.py\n  core.py               # Main CurriculumCurator class\n  cli.py                # Command-line interface\n\n  prompt/\n    __init__.py\n    registry.py         # Prompt registry implementation\n\n  llm/\n    __init__.py\n    manager.py          # LLM integration layer\n\n  content/\n    __init__.py\n    transformer.py      # Content transformation utilities\n\n  workflow/\n    __init__.py\n    engine.py           # Workflow orchestration\n    steps.py            # Step implementations\n\n  validation/\n    __init__.py\n    manager.py          # Validation coordination\n    validators/         # Individual validator implementations\n      __init__.py\n      similarity.py\n      structure.py\n      readability.py\n\n  remediation/\n    __init__.py\n    manager.py          # Remediation coordination\n    remediators/        # Individual remediator implementations\n      __init__.py\n      content_merger.py\n      sentence_splitter.py\n\n  output/\n    __init__.py\n    manager.py          # Output generation\n\n  persistence/\n    __init__.py\n    manager.py          # Data persistence\n\n  utils/\n    __init__.py\n    logging.py          # Logging configuration\n    exceptions.py       # Exception hierarchy\n</code></pre>"},{"location":"design/#82-dependencies","title":"8.2 Dependencies","text":"<p>The following external dependencies are used:</p> <ul> <li>LiteLLM: For LLM provider integration</li> <li>python-frontmatter: For parsing YAML front matter in prompt files</li> <li>PyYAML: For configuration loading and saving</li> <li>structlog: For structured logging</li> <li>backoff: For retry mechanics</li> <li>scikit-learn: For content similarity calculations</li> <li>Pandoc: External dependency for format conversion</li> <li>FastHTML: For building the web interface backend with server-side rendering</li> <li>HTMX: For interactive web functionality without complex JavaScript</li> <li>Pico CSS: Lightweight CSS framework included with FastHTML by default</li> <li>Typer: For building the CLI interface</li> <li>Rich: For terminal formatting and display</li> </ul>"},{"location":"design/#83-development-tools","title":"8.3 Development Tools","text":"<p>The project utilizes several modern Python development tools:</p> <ul> <li>uv: Fast package installer and virtual environment manager</li> <li>ruff: Fast Python linter and formatter</li> <li>pytest: Testing framework</li> <li>mkdocs: Documentation generation</li> </ul>"},{"location":"design/#84-configuration","title":"8.4 Configuration","text":"<p>The system is highly configurable through YAML files:</p> <pre><code># System configuration\nsystem:\n  persistence_dir: \".curriculum_curator\"\n  output_dir: \"output\"\n  log_level: \"INFO\"\n\n# LLM providers configuration\nllm:\n  default_provider: \"ollama\"\n  providers:\n    anthropic:\n      api_key: \"env(ANTHROPIC_API_KEY)\"\n      default_model: \"claude-3-haiku\"\n      cost_per_1k_tokens:\n        input: 0.25\n        output: 0.75\n      models:\n        claude-3-haiku: {}\n        claude-3-opus:\n          cost_per_1k_tokens:\n            input: 15.00\n            output: 75.00\n\n    openai:\n      api_key: \"env(OPENAI_API_KEY)\"\n      default_model: \"gpt-3.5-turbo\"\n      cost_per_1k_tokens:\n        input: 0.50\n        output: 1.50\n      models:\n        gpt-3.5-turbo: {}\n        gpt-4-turbo:\n          cost_per_1k_tokens:\n            input: 10.00\n            output: 30.00\n\n    ollama:\n      base_url: \"http://localhost:11434\"\n      default_model: \"llama3\"\n      cost_per_1k_tokens:\n        input: 0.00\n        output: 0.00\n      models:\n        llama3: {}\n        mistral: {}\n\n    groq:\n      api_key: \"env(GROQ_API_KEY)\"\n      default_model: \"llama3-8b-8192\"\n      cost_per_1k_tokens:\n        input: 0.10\n        output: 0.30\n      models:\n        llama3-8b-8192: {}\n\n    gemini:\n      api_key: \"env(GOOGLE_API_KEY)\"\n      default_model: \"gemini-pro\"\n      cost_per_1k_tokens:\n        input: 0.50\n        output: 1.50\n      models:\n        gemini-pro: {}\n\n# Prompt registry configuration\nprompts:\n  base_path: \"./prompts\"\n\n# Validation configuration\nvalidation:\n  similarity:\n    threshold: 0.85\n    model: \"all-MiniLM-L6-v2\"\n\n  structure:\n    slides:\n      min_sections: 5\n      required_sections: [\"title\", \"objectives\", \"summary\"]\n\n  readability:\n    max_avg_sentence_length: 25\n    min_flesch_reading_ease: 60\n\n# Remediation configuration\nremediation:\n  content_merger:\n    similarity_threshold: 0.8\n\n  sentence_splitter:\n    enabled: true\n\n# Output configuration\noutput:\n  html_options: [\"--template=default\", \"--css=styles.css\"]\n  pdf_options: [\"--pdf-engine=wkhtmltopdf\"]\n  docx_options: [\"--reference-doc=template.docx\"]\n  slides_options: [\"--variable=theme:moon\"]\n</code></pre>"},{"location":"design/#9-deployment-strategy","title":"9. Deployment Strategy","text":"<p>CurriculumCurator can be deployed in several ways to meet different user needs.</p>"},{"location":"design/#91-package-installation","title":"9.1 Package Installation","text":"<p>The primary distribution method is via pip:</p> <pre><code>pip install curriculum-curator\n</code></pre> <p>This installs the core package and its Python dependencies. Users will need to install Pandoc separately for output format conversion.</p>"},{"location":"design/#92-docker-container","title":"9.2 Docker Container","text":"<p>For consistent deployment across environments, a Docker container is provided:</p> <pre><code>FROM python:3.10-slim\n\n# Install Pandoc and other dependencies\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y --no-install-recommends \\\n    pandoc \\\n    wkhtmltopdf \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install curriculum-curator\nCOPY . /app\nWORKDIR /app\nRUN pip install -e .\n\n# Create volume mount points\nVOLUME /data/prompts\nVOLUME /data/output\nVOLUME /data/sessions\n\n# Set environment variables\nENV CURATOR_CONFIG=/data/config.yaml\n\n# Set entrypoint\nENTRYPOINT [\"curator\"]\n</code></pre> <p>This allows users to run CurriculumCurator with all dependencies pre-installed:</p> <pre><code>docker run -v ./prompts:/data/prompts -v ./output:/data/output -v ./config.yaml:/data/config.yaml curriculum-curator run standard_course --var course_title=\"Python Programming\"\n</code></pre>"},{"location":"design/#93-github-releases","title":"9.3 GitHub Releases","text":"<p>Pre-built wheels and installation instructions are provided via GitHub Releases, making it easy for users to install specific versions.</p>"},{"location":"design/#94-documentation","title":"9.4 Documentation","text":"<p>Comprehensive documentation is hosted on GitHub Pages using mkdocs, including:</p> <ul> <li>Installation instructions</li> <li>Configuration guide</li> <li>Prompt authoring guidelines</li> <li>Workflow examples</li> <li>API reference</li> <li>CLI command reference</li> </ul>"},{"location":"design/#95-local-development","title":"9.5 Local Development","text":"<p>For developers contributing to the project or extending it:</p> <pre><code># Clone the repository\ngit clone https://github.com/organization/curriculum-curator.git\ncd curriculum-curator\n\n# Create virtual environment and install in development mode\nuv venv\nsource .venv/bin/activate\nuv pip install -e \".[dev]\"\n\n# Run tests\npytest\n\n# Run linter and formatter\nruff check .\nruff format .\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"design/#10-component-interaction-diagram","title":"10. Component Interaction Diagram","text":"<pre><code>graph TD\n    subgraph User_Configuration\n        direction LR\n        Config[\"YAML Config Files\"]\n        UserPrompts[\"prompts/*.txt\"]\n    end\n\n    subgraph CurriculumCurator_Core\n        direction TB\n        WorkflowEngine[\"Workflow Engine\"]\n        PromptRegistry[\"Prompt Registry\"]\n        LLMLayer[\"LLM Integration Layer&lt;br/&gt;(using LiteLLM)\"]\n        Transformation[\"Content Transformation Layer\"]\n        Validation[\"Validation Framework\"]\n        Remediation[\"Remediation System\"]\n        Output[\"Output Production\"]\n        Persistence[\"Persistence Manager\"]\n    end\n\n    subgraph External_Systems\n        direction RL\n        LLMAPIs[\"LLM APIs&lt;br/&gt;(OpenAI, Claude, Gemini, Groq, Ollama)\"]\n        Pandoc[\"Pandoc/Quarto\"]\n    end\n\n    subgraph Interfaces\n        direction TB\n        CLI[\"CLI Interface\"]\n        API[\"Python API\"]\n        WebUI[\"Web Interface (Future)\"]\n        TUI[\"TUI Interface (Future)\"]\n    end\n\n    %% Interactions %%\n    Config --&gt; WorkflowEngine\n    Config --&gt; LLMLayer\n    Config --&gt; Validation\n    Config --&gt; Remediation\n    Config --&gt; Output\n    Config --&gt; Persistence\n    UserPrompts --&gt; PromptRegistry\n\n    WorkflowEngine -- \"Reads Steps\" --&gt; Config\n    WorkflowEngine -- \"Gets Prompt Template\" --&gt; PromptRegistry\n    WorkflowEngine -- \"Requests Generation\" --&gt; LLMLayer\n    LLMLayer -- \"Returns Raw Content\" --&gt; WorkflowEngine\n    WorkflowEngine -- \"Sends for Transformation\" --&gt; Transformation\n    Transformation -- \"Returns Structured Content\" --&gt; WorkflowEngine\n    WorkflowEngine -- \"Sends Content for Validation\" --&gt; Validation\n    Validation -- \"Returns Validation Issues\" --&gt; WorkflowEngine\n    WorkflowEngine -- \"Sends Content+Issues for Remediation\" --&gt; Remediation\n    Remediation -- \"Returns Remediated Content\" --&gt; WorkflowEngine\n    WorkflowEngine -- \"Manages Context\" --&gt; WorkflowEngine\n    WorkflowEngine -- \"Sends Final Content\" --&gt; Output\n    WorkflowEngine -- \"Persists State\" --&gt; Persistence\n\n    PromptRegistry -- \"Loads Prompts\" --&gt; UserPrompts\n    LLMLayer -- \"Gets Provider Config\" --&gt; Config\n    LLMLayer -- \"Calls External API\" --&gt; LLMAPIs\n    Validation -- \"Gets Rules\" --&gt; Config\n    Output -- \"Calls External Tool\" --&gt; Pandoc\n\n    CLI --&gt; WorkflowEngine\n    API --&gt; WorkflowEngine\n    WebUI --&gt; WorkflowEngine\n    TUI --&gt; WorkflowEngine\n\n    Output --&gt; GeneratedFiles[\"Generated Curriculum Files\"]\n    Persistence --&gt; SessionFiles[\"Session Records\"]\n</code></pre>"},{"location":"design/#11-benefits-of-this-approach","title":"11. Benefits of This Approach","text":"<ol> <li>Simplicity (User): Filesystem prompts with standard YAML front matter are easy to manage; Markdown focus is intuitive.</li> <li>Maintainability: Clear separation of concerns; LLM broker handles provider complexity; standard front matter parsing.</li> <li>Flexibility: Highly configurable via YAML; extensible architecture.</li> <li>Performance: Asynchronous processing for efficient LLM usage.</li> <li>Quality: Built-in validation and remediation steps.</li> <li>Output Versatility: Leverages powerful external tools (Pandoc) for broad format support from a common Markdown base.</li> <li>Cost Transparency: Token usage and cost tracking at every step.</li> <li>Provider Independence: Support for multiple LLM providers with seamless fallbacks.</li> </ol>"},{"location":"design/#12-conclusion","title":"12. Conclusion","text":"<p>This design document outlines a comprehensive architecture for CurriculumCurator, an educational content workflow orchestration tool. The system leverages the power of Large Language Models while providing a flexible, configurable framework that can be adapted to various educational content creation needs.</p> <p>The implementation follows modern Python development practices, with clear separation of concerns, robust error handling, and a focus on usability. By combining prompt-centric content generation with workflow-driven processes, CurriculumCurator streamlines the creation of high-quality educational materials while maintaining full control and transparency.# CurriculumCurator: Comprehensive Design Document</p>"},{"location":"adr/","title":"Architecture Decision Records","text":"<p>This section contains Architecture Decision Records (ADRs) documenting the significant architectural decisions made during the development of Curriculum Curator.</p>"},{"location":"adr/#what-are-adrs","title":"What are ADRs?","text":"<p>Architecture Decision Records are documents that capture important architectural decisions made along with their context and consequences. Each ADR describes a choice the team made and why that choice was made.</p>"},{"location":"adr/#why-do-we-use-adrs","title":"Why do we use ADRs?","text":"<p>ADRs help us:</p> <ul> <li>Document important decisions for future reference</li> <li>Communicate the reasoning behind choices to new team members</li> <li>Track the evolution of the system architecture over time</li> <li>Provide context for current design decisions</li> </ul>"},{"location":"adr/#available-adrs","title":"Available ADRs","text":"<p>Here are the current ADRs for the Curriculum Curator project:</p> ADR Title Status ADR-0001 Record Architecture Decisions Accepted ADR-0002 Validation and Remediation Design Accepted ADR-0003 Workflow Configuration Format Accepted ADR-0004 Interactive Workflow Builder Accepted ADR-0005 Interactive Interfaces Accepted"},{"location":"adr/#adr-process","title":"ADR Process","text":"<ol> <li>Proposal: When a significant architectural decision needs to be made, an ADR is drafted</li> <li>Discussion: The team discusses the proposed ADR</li> <li>Acceptance: Once consensus is reached, the ADR is accepted</li> <li>Implementation: The decision is implemented in the codebase</li> <li>Review: ADRs can be reviewed and updated as the system evolves</li> </ol>"},{"location":"adr/#adr-template","title":"ADR Template","text":"<p>When creating a new ADR, use the template as a starting point.</p>"},{"location":"adr/0001-record-architecture-decisions/","title":"Record Architecture Decisions","text":""},{"location":"adr/0001-record-architecture-decisions/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-record-architecture-decisions/#context","title":"Context","text":"<p>We need to record the architectural decisions made on this project to ensure:</p> <ol> <li>We have a record of what decisions were made and why</li> <li>New team members can quickly understand past decisions</li> <li>We can revisit decisions when requirements or context changes</li> </ol> <p>Architecture decisions include: - Technology choices (frameworks, libraries, tools) - Design patterns and approaches - Trade-offs between competing concerns - API and interface designs - Data structures and formats</p>"},{"location":"adr/0001-record-architecture-decisions/#decision","title":"Decision","text":"<p>We will use Architecture Decision Records, as described by Michael Nygard in this article.</p> <p>Each ADR will be stored in the docs/adr directory as a Markdown file with a sequential number prefix (NNNN).</p>"},{"location":"adr/0001-record-architecture-decisions/#consequences","title":"Consequences","text":"<ul> <li>Team members and future maintainers can understand why certain decisions were made</li> <li>The process of creating ADRs forces us to think through decisions more carefully</li> <li>We have a historical record that can be referenced when evaluating changes</li> <li>There is a small overhead in documenting decisions</li> </ul>"},{"location":"adr/0001-record-architecture-decisions/#alternatives-considered","title":"Alternatives Considered","text":"<ul> <li>Documenting decisions in a wiki (rejected because it would be separate from the code)</li> <li>Not documenting decisions formally (rejected due to knowledge loss over time)</li> <li>Using a more complex decision documentation format (rejected in favor of simplicity)</li> </ul>"},{"location":"adr/0002-validation-remediation-design/","title":"2. Validation and Remediation Design","text":"<p>Date: 2025-04-05</p>"},{"location":"adr/0002-validation-remediation-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-validation-remediation-design/#context","title":"Context","text":"<p>The Curriculum Curator needs to ensure high-quality educational content. This requires both validation (detecting quality issues) and remediation (fixing those issues). We need to define the relationship between these two components and how they should work together in the system.</p>"},{"location":"adr/0002-validation-remediation-design/#decision","title":"Decision","text":"<p>We will implement a two-stage approach with validation followed by remediation, but allow for flexibility in how they're used:</p> <ol> <li>Validation System:</li> <li>Modular validators that check specific aspects of content quality</li> <li>Each validator focuses on a single concern (readability, structure, factuality, etc.)</li> <li>Validation produces a list of issues with detailed metadata</li> <li> <p>Validators don't modify content; they only detect problems</p> </li> <li> <p>Remediation System:</p> </li> <li>Modular remediators that fix specific types of issues</li> <li>Organized into categories based on remediation strategy:<ul> <li>AutoFix: Automated fixes without LLM assistance (format, spelling, etc.)</li> <li>Rewrite: LLM-assisted content rewriting (rephrasing, elaboration, etc.)</li> <li>Workflow: Process actions that might require human intervention (flagging, quarantine, etc.)</li> </ul> </li> <li> <p>Remediators can be invoked either:</p> <ul> <li>Reactively in response to validation failures</li> <li>Proactively as part of content processing (optional)</li> </ul> </li> <li> <p>Configuration-Driven Behavior:</p> </li> <li>Both validators and remediators are configurable through the application configuration</li> <li>Configuration determines which validators and remediators are active</li> <li> <p>Default behavior is validation-driven but can be customized</p> </li> <li> <p>Workflow Integration:</p> </li> <li>Standard workflow steps include validation and remediation</li> <li>Workflows can be configured to:<ul> <li>Validate and fail on issues</li> <li>Validate and auto-remediate</li> <li>Validate, remediate, and re-validate</li> <li>Skip validation and apply proactive remediation</li> </ul> </li> </ol>"},{"location":"adr/0002-validation-remediation-design/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":"<ol> <li>Combined Validator-Remediator Components:</li> <li>Components that both detect and fix issues</li> <li>Rejected because it violates single responsibility principle</li> <li> <p>Would make it harder to mix and match validation and remediation strategies</p> </li> <li> <p>LLM-Only Approach:</p> </li> <li>Using LLMs for all validation and remediation</li> <li>Rejected because specialized tools are more efficient for many tasks</li> <li> <p>Hybrid approach using specialized tools and LLMs is more flexible</p> </li> <li> <p>Manual Review Only:</p> </li> <li>Flagging all issues for human review</li> <li>Rejected because many issues can be fixed automatically</li> <li>Retained as an option for critical issues</li> </ol>"},{"location":"adr/0002-validation-remediation-design/#planned-validator-types","title":"Planned Validator Types","text":"Category Validator Type Description Quality Structure Checks if content has required sections and organization Quality Readability Evaluates reading level, sentence complexity, etc. Quality Similarity Detects duplicate or highly similar content Quality Coherence Checks logical flow and transitions Quality Completeness Verifies all required content is present Quality Consistency Identifies internal contradictions Quality Generic Content Flags overly generic or formulaic content Accuracy Factuality Checks for factual accuracy or hallucinations Accuracy References Validates citations and references Alignment Objectives Verifies alignment with learning objectives Alignment Relevance Checks if content stays on topic Alignment Age Appropriateness Ensures content is suitable for target audience Alignment Instruction Adherence Verifies compliance with prompt instructions Style Bias Detects potential bias in language or examples Style Tone Checks if tone matches requirements Language Language Detection Identifies the language of content Language Grammar Checks for grammatical correctness Language Spelling Detects spelling errors Safety Content Safety Checks for harmful or inappropriate content"},{"location":"adr/0002-validation-remediation-design/#planned-remediator-types","title":"Planned Remediator Types","text":"Category Remediator Type Description AutoFix Format Corrector Fixes markdown syntax and formatting AutoFix Sentence Splitter Breaks long sentences to improve readability AutoFix Terminology Enforcer Ensures consistent terminology usage AutoFix Synonym Replacer Varies word choice to reduce repetition AutoFix Punctuation Corrector Fixes punctuation errors AutoFix Filler Remover Eliminates vague or generic filler content AutoFix Grammar Corrector Fixes grammatical errors AutoFix Spelling Corrector Fixes spelling errors Rewrite Rephrasing Prompter Uses LLM to rewrite problematic content Rewrite Detail Enhancer Uses LLM to add specific details Rewrite Tone Adjuster Uses LLM to adjust content tone Rewrite Prompt Refiner Suggests improvements to original prompt Workflow Flag for Review Marks content for human review Workflow Quarantine Content Prevents problematic content from inclusion Workflow Content Merger Combines or reconciles duplicate content Language Translator Translates content between languages"},{"location":"adr/0002-validation-remediation-design/#validation-remediation-mapping","title":"Validation-Remediation Mapping","text":"<p>Some validators have natural corresponding remediators:</p> Validator Remediator Readability Sentence Splitter Similarity Rephrasing Prompter Structure Format Corrector Factuality Flag for Review Bias Flag for Review Grammar Grammar Corrector Spelling Spelling Corrector Language Detection Translator"},{"location":"adr/0002-validation-remediation-design/#consequences","title":"Consequences","text":"<p>Positive: - Clear separation of concerns between validation and remediation - Flexible architecture that can be extended with new validators and remediators - Configurable behavior to support different use cases - Support for both automated and human-in-the-loop processes</p> <p>Negative: - Increased system complexity - Need to maintain mappings between validators and appropriate remediators - Configuration becomes more complex</p> <p>Neutral: - Validators and remediators need to follow consistent interfaces - Dependency on LLMs for some remediation strategies introduces variability</p>"},{"location":"adr/0003-workflow-configuration-format/","title":"ADR 0003: Workflow Configuration Format","text":""},{"location":"adr/0003-workflow-configuration-format/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-workflow-configuration-format/#context","title":"Context","text":"<p>The Curriculum Curator system relies on a workflow engine to orchestrate the generation, validation, remediation, and output of educational content. We need a standardized format for defining these workflows that is:</p> <ol> <li>Human-readable and easy to edit</li> <li>Extensible to accommodate future workflow patterns</li> <li>Capable of being loaded dynamically at runtime</li> <li>Provides defaults and overrides for common properties</li> </ol>"},{"location":"adr/0003-workflow-configuration-format/#decision","title":"Decision","text":"<p>We will use YAML as the configuration format for workflow definitions with a standardized schema that supports defaults and step-specific overrides. Workflow definitions will be stored in standalone files that can be discovered at runtime.</p>"},{"location":"adr/0003-workflow-configuration-format/#schema","title":"Schema","text":"<p>The workflow configuration format will follow this structure:</p> <pre><code># Top-level workflow definition\nname: \"workflow_name\"  # Required: Unique identifier for the workflow (should follow snake_case)\ndescription: \"Workflow description\"  # Required: Human-readable description of the workflow\n\n# Optional global defaults that apply to all steps unless overridden\ndefaults:\n  llm_model_alias: \"default_smart\"  # Default LLM model to use for all prompt steps\n  output_format: \"raw\"  # Default output format for all prompt steps\n  validators: [\"readability\", \"structure\"]  # Default validators for all validation steps\n  remediators: [\"format_corrector\", \"sentence_splitter\"]  # Default remediators\n\n# Required: List of steps defining the workflow execution\nsteps:\n  # Each step defines an action in the workflow\n  - name: \"step_name\"  # Required: Unique name for this step\n    type: \"prompt\"  # Required: Step type (prompt, validation, remediation, output)\n    # Additional parameters based on step type...\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#step-types-and-parameters","title":"Step Types and Parameters","text":""},{"location":"adr/0003-workflow-configuration-format/#prompt-step","title":"Prompt Step","text":"<p>Used to generate content by executing a prompt with an LLM.</p> <pre><code>- name: \"generate_overview\"\n  type: \"prompt\"\n  prompt: \"course/overview.txt\"  # Required: Path to the prompt template\n  llm_model_alias: \"default_smart\"  # Optional: LLM model to use\n  output_format: \"raw\"  # Optional: Format for output (raw, json, list, html)\n  output_variable: \"course_overview\"  # Required: Variable to store the result\n  transformation_rules: {}  # Optional: Special rules for content transformation\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#validation-step","title":"Validation Step","text":"<p>Used to validate content against a set of rules.</p> <pre><code>- name: \"validate_lecture\"\n  type: \"validation\"\n  content_variable: \"lecture_content\"  # Required: Content to validate\n  validators: [\"readability\", \"structure\"]  # Required: Validators to apply\n  output_variable: \"validation_issues\"  # Required: Variable to store issues\n  validation_config:  # Optional: Additional configuration for validators\n    similarity:\n      threshold: 0.8\n    structure:\n      required_sections: [\"introduction\", \"conclusion\"]\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#remediation-step","title":"Remediation Step","text":"<p>Used to fix issues found during validation.</p> <pre><code>- name: \"remediate_lecture\"\n  type: \"remediation\"\n  content_variable: \"lecture_content\"  # Required: Content to remediate\n  issues_variable: \"validation_issues\"  # Required: Issues to fix\n  output_variable: \"remediated_lecture\"  # Required: Variable to store fixed content\n  actions_variable: \"remediation_actions\"  # Optional: Variable to store actions taken\n  remediation_config:  # Optional: Additional configuration for remediators\n    format_corrector:\n      aggressive: true\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#output-step","title":"Output Step","text":"<p>Used to generate output files from content.</p> <pre><code>- name: \"generate_outputs\"\n  type: \"output\"\n  output_mapping:  # Required: Maps variables to output filenames\n    course_overview: \"overview.md\"\n    remediated_lecture: \"lecture.md\"\n  output_dir: \"output/{course_slug}/{module_id}\"  # Required: Output directory\n  output_variable: \"output_files\"  # Optional: Variable to store output file paths\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#future-step-types-planned","title":"Future Step Types (Planned)","text":""},{"location":"adr/0003-workflow-configuration-format/#conditional-step","title":"Conditional Step","text":"<p>Executes steps conditionally based on a condition.</p> <pre><code>- name: \"conditional_step\"\n  type: \"conditional\"\n  condition: \"validation_issues|length &gt; 0\"  # Required: Condition to evaluate\n  if_steps:  # Required: Steps to execute if condition is true\n    - name: \"remediate_content\"\n      type: \"remediation\"\n      # ...\n  else_steps:  # Optional: Steps to execute if condition is false\n    - name: \"skip_remediation\"\n      type: \"prompt\"\n      # ...\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#loop-step","title":"Loop Step","text":"<p>Executes steps repeatedly for each item in a collection.</p> <pre><code>- name: \"process_modules\"\n  type: \"loop\"\n  items_variable: \"modules\"  # Required: Variable containing items to iterate over\n  item_variable: \"current_module\"  # Required: Variable to store current item\n  steps:  # Required: Steps to execute for each item\n    - name: \"process_module\"\n      type: \"prompt\"\n      # ...\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#parallel-step","title":"Parallel Step","text":"<p>Executes steps in parallel.</p> <pre><code>- name: \"parallel_processing\"\n  type: \"parallel\"\n  max_concurrency: 3  # Optional: Maximum number of concurrent tasks\n  steps:  # Required: Steps to execute in parallel\n    - name: \"task1\"\n      type: \"prompt\"\n      # ...\n    - name: \"task2\"\n      type: \"prompt\"\n      # ...\n</code></pre>"},{"location":"adr/0003-workflow-configuration-format/#discovery-mechanism","title":"Discovery Mechanism","text":"<p>Workflow configurations will be discovered from files in the following locations: 1. <code>/examples/workflows/</code> - For built-in example workflows 2. <code>/workflows/</code> - For user-defined workflows</p> <p>YAML files in these directories will be loaded automatically when the application starts.</p>"},{"location":"adr/0003-workflow-configuration-format/#implementation-details","title":"Implementation Details","text":"<ol> <li>The workflow engine will support defaults by merging workflow-level defaults with step-specific configurations.</li> <li>Step-specific configurations will override workflow-level defaults.</li> <li>The system will validate workflow configurations against a schema to catch errors early.</li> <li>Workflow configurations will be versionable and shareable between users.</li> </ol>"},{"location":"adr/0003-workflow-configuration-format/#consequences","title":"Consequences","text":""},{"location":"adr/0003-workflow-configuration-format/#positive","title":"Positive","text":"<ul> <li>Users can create and modify workflows without changing code</li> <li>Workflows can be easily shared and versioned</li> <li>Common configurations can be defaulted at the workflow level</li> <li>New step types can be added without breaking existing workflows</li> </ul>"},{"location":"adr/0003-workflow-configuration-format/#negative","title":"Negative","text":"<ul> <li>Additional complexity in the workflow execution engine</li> <li>Need for backwards compatibility when changing the schema</li> <li>Potential for configuration errors if not validated properly</li> </ul>"},{"location":"adr/0003-workflow-configuration-format/#references","title":"References","text":"<ul> <li>YAML Specification</li> <li>Configuration-Driven Workflow Design</li> </ul>"},{"location":"adr/0004-interactive-workflow-builder/","title":"4. Interactive Workflow Builder","text":""},{"location":"adr/0004-interactive-workflow-builder/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-interactive-workflow-builder/#context","title":"Context","text":"<p>Building and editing workflows in the Curriculum Curator system requires creating and modifying YAML configuration files. This presents several challenges:</p> <ol> <li>High barrier to entry: Users who are unfamiliar with YAML syntax face difficulties when creating or modifying workflows.</li> <li>Error-prone: Manual editing of YAML files can lead to syntax errors, invalid configurations, and difficult-to-debug issues.</li> <li>Discoverability: Users may not be aware of all available components (prompts, validators, remediators) that can be used in workflows.</li> <li>Validation delay: Errors in the workflow configurations are only discovered when the workflow is run, leading to a longer feedback cycle.</li> </ol> <p>We need a way to make workflow creation more accessible to users who aren't familiar with YAML syntax or the full system architecture, while ensuring valid configurations.</p>"},{"location":"adr/0004-interactive-workflow-builder/#decision","title":"Decision","text":"<p>We will implement an interactive, menu-driven workflow builder as a CLI subcommand (<code>build-workflow</code>) that allows users to create and edit workflow configurations through a guided process. The builder will:</p> <ol> <li>Provide a structured interface for all workflow components (prompt steps, validation steps, remediation steps, output steps)</li> <li>Query the system for available components (prompts, validators, remediators) and present them as options</li> <li>Validate the workflow in real-time as it's being built</li> <li>Allow loading existing workflows as a base for creating new ones</li> <li>Implement workflow editing capabilities (add, remove, modify, reorder steps)</li> <li>Save valid configurations to YAML files</li> </ol> <p>This approach offers a middle ground between direct YAML editing and a full web/TUI interface, making the system more accessible without requiring extensive UI development.</p>"},{"location":"adr/0004-interactive-workflow-builder/#consequences","title":"Consequences","text":""},{"location":"adr/0004-interactive-workflow-builder/#positive","title":"Positive","text":"<ol> <li>Reduced learning curve: Users can create workflows without needing to understand YAML syntax or the full configuration schema.</li> <li>Improved discoverability: Available components are presented as menu options, making them more discoverable.</li> <li>Immediate validation: Errors are caught during the building process rather than at runtime.</li> <li>Quicker onboarding: New users can more quickly become productive with the system.</li> <li>Extensibility: The builder can be extended as new step types or features are added to the system.</li> </ol>"},{"location":"adr/0004-interactive-workflow-builder/#negative","title":"Negative","text":"<ol> <li>CLI limitations: The CLI interface has inherent limitations compared to a full GUI/TUI.</li> <li>Added complexity: We now have two ways to create workflows (direct YAML editing and the builder), which increases the surface area for bugs.</li> <li>Maintenance overhead: Changes to the workflow configuration schema will require updates to both the schema validation and the builder interface.</li> </ol>"},{"location":"adr/0004-interactive-workflow-builder/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li> <p>Web UI: A browser-based interface would provide a richer user experience but would require significant additional infrastructure, dependencies, and maintenance.</p> </li> <li> <p>Full TUI (Terminal User Interface): A more comprehensive terminal UI using libraries like Textual could provide a richer experience but would require more development effort and introduce additional dependencies.</p> </li> <li> <p>Configuration generator scripts: We could provide helper scripts to generate workflow YAML files, but these would be less interactive and flexible than a full builder.</p> </li> <li> <p>No builder: Continue requiring users to edit YAML files directly with improved documentation and examples. This would not address the accessibility concerns.</p> </li> </ol> <p>We chose the interactive CLI builder approach because it strikes a good balance between accessibility and development cost. It addresses the immediate need without overcommitting to a specific UI technology. This approach also allows us to gather user feedback before potentially investing in a more comprehensive web or TUI solution in the future.</p>"},{"location":"adr/0005-interactive-interfaces/","title":"5. Interactive Interfaces","text":""},{"location":"adr/0005-interactive-interfaces/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-interactive-interfaces/#context","title":"Context","text":"<p>Following the implementation of the interactive workflow builder (ADR-0004), we recognized an opportunity to further improve the user experience by creating additional interactive interfaces for other system components. Specifically:</p> <ol> <li>Prompt Management: Creating and editing prompts required direct file editing with a potentially steep learning curve for YAML front matter.</li> <li>Command Discoverability: Users needed to remember CLI commands and parameters for different operations.</li> <li>Context Switching: Moving between different tasks like running workflows, editing prompts, and building workflows required different command syntax.</li> </ol> <p>In educational content creation contexts, many potential users may not be comfortable with command-line interfaces and direct file editing, which could limit adoption.</p>"},{"location":"adr/0005-interactive-interfaces/#decision","title":"Decision","text":"<p>We will implement a comprehensive suite of interactive interfaces to make the system more accessible:</p> <ol> <li>Interactive Prompt Editor: A menu-driven interface for creating and editing prompts, with:</li> <li>Template selection for different content types</li> <li>Front matter validation</li> <li>System editor integration</li> <li> <p>Directory structure management</p> </li> <li> <p>Top-Level Interactive Mode: A unified menu interface that provides access to all system functionality:</p> </li> <li>Running workflows</li> <li>Building/editing workflows</li> <li>Editing prompts</li> <li> <p>Initializing projects</p> </li> <li> <p>Consistent UI Components: Standardize on the Rich library for all interactive interfaces, providing:</p> </li> <li>Colored output with consistent styling</li> <li>Tables for structured information</li> <li>Confirmation prompts for potentially destructive actions</li> <li>Progress indicators</li> </ol> <p>This approach builds on the success of the interactive workflow builder while extending the same user experience paradigm to other parts of the system.</p>"},{"location":"adr/0005-interactive-interfaces/#consequences","title":"Consequences","text":""},{"location":"adr/0005-interactive-interfaces/#positive","title":"Positive","text":"<ol> <li>Reduced Learning Curve: Users can accomplish tasks without needing to know specific command syntax or file formats.</li> <li>Guided Workflows: Step-by-step menus guide users through complex processes like prompt creation.</li> <li>Better Prompt Quality: Templates and validation ensure that prompts include all necessary components.</li> <li>Unified Experience: The interactive mode provides a single entry point for all operations.</li> <li>Progressive Disclosure: Complex options are revealed only when needed, reducing cognitive load.</li> </ol>"},{"location":"adr/0005-interactive-interfaces/#negative","title":"Negative","text":"<ol> <li>Interface Maintenance: Multiple interfaces require consistent maintenance as the underlying functionality evolves.</li> <li>Increased Code Complexity: Interactive interfaces add more code paths to maintain and test.</li> <li>Terminal Limitations: Terminal-based interfaces have inherent limitations compared to web or native GUIs.</li> <li>Documentation Overhead: We must document both the CLI commands and the interactive interfaces.</li> </ol>"},{"location":"adr/0005-interactive-interfaces/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Web Interface: A browser-based UI would provide a richer experience but require significantly more infrastructure.</li> <li>GUI Application: A native GUI application could offer a polished experience but would add platform dependencies and complexity.</li> <li>Direct File Editing Only: We could focus solely on improving documentation for direct file editing, but this would maintain a high barrier to entry.</li> <li>Configuration Generation Scripts: Simple scripts to generate configurations would be easier to implement but less flexible.</li> </ol> <p>We chose the interactive CLI approach because it strikes the right balance between usability and implementation complexity. It addresses immediate user needs without overcommitting to a specific UI technology, allowing us to gather user feedback before potentially investing in a more sophisticated interface in the future.</p>"},{"location":"adr/template/","title":"[Title of the ADR]","text":""},{"location":"adr/template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded by ADR-NNNN]</p>"},{"location":"adr/template/#context","title":"Context","text":"<p>[Describe the context and problem statement that this decision addresses. What is the issue that we're seeing that is motivating this decision or change?]</p>"},{"location":"adr/template/#decision","title":"Decision","text":"<p>[Describe the decision that was made, clearly stating what the team has agreed to do.]</p>"},{"location":"adr/template/#consequences","title":"Consequences","text":"<p>[What becomes easier or more difficult to do because of this change? Are there any risks introduced by this decision?]</p>"},{"location":"adr/template/#alternatives-considered","title":"Alternatives Considered","text":"<p>[What other options were considered, and why were they not chosen?]</p>"},{"location":"api/config/","title":"Configuration System","text":""},{"location":"api/config/#overview","title":"Overview","text":"<p>Curriculum Curator uses Pydantic for configuration validation and type safety. Pydantic is a data validation library that uses Python type annotations to validate data structures and provide helpful error messages.</p>"},{"location":"api/config/#configuration-models","title":"Configuration Models","text":"<p>The configuration system is built around a hierarchy of Pydantic models, with <code>AppConfig</code> as the root model. These models define the expected structure of the configuration and provide automatic validation.</p>"},{"location":"api/config/#how-pydantic-models-work","title":"How Pydantic Models Work","text":"<p>Pydantic models are similar to database schemas or TypeScript interfaces - they define the shape and constraints of data. They:</p> <ul> <li>Enforce types and validation rules</li> <li>Generate clear error messages when data doesn't match expectations</li> <li>Provide automatic conversion between types when possible (e.g., string to int)</li> <li>Allow for default values and optional fields</li> </ul>"},{"location":"api/config/#core-configuration-models","title":"Core Configuration Models","text":""},{"location":"api/config/#appconfig","title":"AppConfig","text":"<p>The root configuration model that contains all other configuration sections:</p> <pre><code>class AppConfig(BaseModel):\n    \"\"\"Overall application configuration.\"\"\"\n\n    system: SystemConfig = Field(default_factory=SystemConfig)\n    llm: LLMConfig = Field(...)  # Required\n    prompts: PromptConfig = Field(default_factory=PromptConfig)\n    validation: Optional[ValidationConfig] = None\n    remediation: Optional[RemediationConfig] = None\n    output: Optional[OutputConfig] = None\n    workflows: Dict[str, WorkflowConfig] = Field(\n        default_factory=dict, description=\"Available workflows\"\n    )\n</code></pre>"},{"location":"api/config/#llm-configuration","title":"LLM Configuration","text":"<p>Models for LLM provider configuration:</p> <pre><code>class LLMConfig(BaseModel):\n    \"\"\"LLM configuration.\"\"\"\n\n    default_provider: str = Field(..., description=\"Default LLM provider to use\")\n    aliases: Dict[str, str] = Field(\n        default_factory=dict, description=\"Model aliases for easier reference\"\n    )\n    providers: Dict[str, LLMProviderConfig] = Field(\n        default_factory=dict, description=\"LLM provider configurations\"\n    )\n</code></pre>"},{"location":"api/config/#workflow-configuration","title":"Workflow Configuration","text":"<p>Models for workflow definitions:</p> <pre><code>class WorkflowConfig(BaseModel):\n    \"\"\"Configuration for a workflow.\"\"\"\n\n    description: str = Field(..., description=\"Description of the workflow\")\n    steps: List[WorkflowStepConfig] = Field(\n        default_factory=list, description=\"Steps in the workflow\"\n    )\n</code></pre>"},{"location":"api/config/#loading-configuration","title":"Loading Configuration","text":"<p>Configuration can be loaded from YAML files using the <code>load_config</code> function:</p> <pre><code>from curriculum_curator.config.utils import load_config\n\n# Load config from a file\nconfig = load_config(\"config.yaml\")\n\n# Access configuration values with type safety\nprovider = config.llm.default_provider\nworkflow_names = list(config.workflows.keys())\n</code></pre>"},{"location":"api/config/#benefits-of-pydantic-for-configuration","title":"Benefits of Pydantic for Configuration","text":"<ol> <li>Type Safety: Configuration errors are caught early with clear error messages</li> <li>Self-Documenting: Models make it clear what configuration options are available</li> <li>IDE Support: Type hints enable autocomplete and inline documentation</li> <li>Validation: Complex validation rules ensure configuration correctness</li> <li>Default Values: Less configuration required for common use cases</li> </ol>"},{"location":"api/config/#example-configuration","title":"Example Configuration","text":"<p>Here's an example of a minimal YAML configuration file:</p> <pre><code>llm:\n  default_provider: openai\n  providers:\n    openai:\n      api_key: env(OPENAI_API_KEY)\n      default_model: gpt-4\n      models:\n        gpt-4: {}\n        gpt-3.5-turbo: {}\n\nworkflows:\n  generate_module:\n    description: Generate a learning module\n    steps:\n      - name: outline\n        type: prompt\n        prompt: module/outline.txt\n        output_variable: module_outline\n      - name: validate_outline\n        type: validation\n        validators: [structure]\n        targets: [module_outline]\n</code></pre>"},{"location":"api/config/#environment-variable-resolution","title":"Environment Variable Resolution","text":"<p>LLM API keys can be specified as environment variables using the <code>env()</code> syntax:</p> <pre><code>llm:\n  providers:\n    openai:\n      api_key: env(OPENAI_API_KEY)\n</code></pre> <p>The Pydantic validator will automatically resolve these references to the actual environment variable values.</p>"},{"location":"api/core/","title":"Core API","text":"<p>The Core API is the central component of the Curriculum Curator system, providing the main entry point and orchestration for the various subsystems.</p>"},{"location":"api/core/#curriculumcurator","title":"CurriculumCurator","text":"<p>The <code>CurriculumCurator</code> class is the main entry point for using the system programmatically:</p> <pre><code>from curriculum_curator.core import CurriculumCurator\n\ncurator = CurriculumCurator(config)\nresult = curator.execute_workflow(\"workflows/my_workflow.yaml\", parameters={\"topic\": \"Python\"})\n</code></pre>"},{"location":"api/core/#class-definition","title":"Class Definition","text":"<pre><code>class CurriculumCurator:\n    \"\"\"\n    Main entry point for the Curriculum Curator system.\n\n    This class provides a simplified interface to the various subsystems,\n    allowing users to easily execute workflows and manage educational content.\n    \"\"\"\n\n    def __init__(self, config=None):\n        \"\"\"\n        Initialize a new CurriculumCurator instance.\n\n        Args:\n            config (dict, optional): Configuration options. If not provided,\n                                    the default configuration will be loaded.\n        \"\"\"\n\n    def execute_workflow(self, workflow_path, parameters=None):\n        \"\"\"\n        Execute a workflow defined in a YAML file.\n\n        Args:\n            workflow_path (str): Path to the workflow YAML file.\n            parameters (dict, optional): Parameters to pass to the workflow.\n\n        Returns:\n            WorkflowResult: The result of the workflow execution.\n        \"\"\"\n\n    def save_result(self, result, output_path):\n        \"\"\"\n        Save a workflow result to a file.\n\n        Args:\n            result (WorkflowResult): The result to save.\n            output_path (str): The path where to save the result.\n\n        Returns:\n            str: The path where the result was saved.\n        \"\"\"\n\n    def load_prompt(self, prompt_path):\n        \"\"\"\n        Load a prompt template from a file.\n\n        Args:\n            prompt_path (str): Path to the prompt template file.\n\n        Returns:\n            str: The prompt template.\n        \"\"\"\n\n    def format_prompt(self, prompt_template, parameters):\n        \"\"\"\n        Format a prompt template with parameters.\n\n        Args:\n            prompt_template (str): The prompt template.\n            parameters (dict): Parameters to fill in the template.\n\n        Returns:\n            str: The formatted prompt.\n        \"\"\"\n\n    def generate_content(self, prompt, model=None, parameters=None):\n        \"\"\"\n        Generate content using an LLM.\n\n        Args:\n            prompt (str): The prompt to send to the LLM.\n            model (str, optional): The LLM model to use.\n            parameters (dict, optional): Parameters for the LLM.\n\n        Returns:\n            str: The generated content.\n        \"\"\"\n\n    def validate_content(self, content, validators=None):\n        \"\"\"\n        Validate content using specified validators.\n\n        Args:\n            content (str): The content to validate.\n            validators (list, optional): List of validators to use.\n\n        Returns:\n            ValidationResult: The validation result.\n        \"\"\"\n\n    def remediate_content(self, content, validation_result, remediators=None):\n        \"\"\"\n        Remediate content based on validation results.\n\n        Args:\n            content (str): The content to remediate.\n            validation_result (ValidationResult): The validation result.\n            remediators (list, optional): List of remediators to use.\n\n        Returns:\n            str: The remediated content.\n        \"\"\"\n</code></pre>"},{"location":"api/core/#workflowresult","title":"WorkflowResult","text":"<p>The <code>WorkflowResult</code> class represents the result of a workflow execution:</p> <pre><code>class WorkflowResult:\n    \"\"\"\n    Represents the result of a workflow execution.\n\n    Attributes:\n        workflow_name (str): Name of the executed workflow.\n        content (str): The generated or processed content.\n        metadata (dict): Additional metadata about the execution.\n        validation_results (ValidationResult, optional): Results of validation.\n        remediation_results (RemediationResult, optional): Results of remediation.\n    \"\"\"\n\n    def __init__(self, workflow_name, content, metadata=None):\n        \"\"\"\n        Initialize a new WorkflowResult.\n\n        Args:\n            workflow_name (str): Name of the executed workflow.\n            content (str): The generated or processed content.\n            metadata (dict, optional): Additional metadata.\n        \"\"\"\n\n    def to_dict(self):\n        \"\"\"\n        Convert the result to a dictionary.\n\n        Returns:\n            dict: Dictionary representation of the result.\n        \"\"\"\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Create a WorkflowResult from a dictionary.\n\n        Args:\n            data (dict): Dictionary representation of a WorkflowResult.\n\n        Returns:\n            WorkflowResult: The created instance.\n        \"\"\"\n</code></pre>"},{"location":"api/core/#functions","title":"Functions","text":"<p>The core module also provides several utility functions:</p>"},{"location":"api/core/#load_config","title":"load_config","text":"<pre><code>def load_config(config_path=None):\n    \"\"\"\n    Load configuration from a file.\n\n    Args:\n        config_path (str, optional): Path to the configuration file.\n                                    If not provided, the default configuration is used.\n\n    Returns:\n        dict: The loaded configuration.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#get_default_config","title":"get_default_config","text":"<pre><code>def get_default_config():\n    \"\"\"\n    Get the default configuration.\n\n    Returns:\n        dict: The default configuration.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#create_workflow","title":"create_workflow","text":"<pre><code>def create_workflow(name, description, stages):\n    \"\"\"\n    Create a new workflow definition.\n\n    Args:\n        name (str): Name of the workflow.\n        description (str): Description of the workflow.\n        stages (list): List of stage definitions.\n\n    Returns:\n        dict: The created workflow definition.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#save_workflow","title":"save_workflow","text":"<pre><code>def save_workflow(workflow, output_path):\n    \"\"\"\n    Save a workflow definition to a file.\n\n    Args:\n        workflow (dict): The workflow definition.\n        output_path (str): Path where to save the workflow.\n\n    Returns:\n        str: The path where the workflow was saved.\n    \"\"\"\n</code></pre>"},{"location":"api/core/#examples","title":"Examples","text":""},{"location":"api/core/#basic-workflow-execution","title":"Basic Workflow Execution","text":"<pre><code>from curriculum_curator.core import CurriculumCurator, load_config\n\n# Load configuration\nconfig = load_config(\"config.yaml\")\n\n# Initialize the curator\ncurator = CurriculumCurator(config)\n\n# Execute a workflow\nresult = curator.execute_workflow(\n    \"workflows/generate_module.yaml\",\n    parameters={\n        \"topic\": \"Introduction to Python\",\n        \"learning_level\": \"beginner\"\n    }\n)\n\n# Save the result\ncurator.save_result(result, \"output/python_module.md\")\n</code></pre>"},{"location":"api/core/#content-generation-and-validation","title":"Content Generation and Validation","text":"<pre><code>from curriculum_curator.core import CurriculumCurator\n\ncurator = CurriculumCurator()\n\n# Load and format a prompt\nprompt_template = curator.load_prompt(\"prompts/module/outline.txt\")\nprompt = curator.format_prompt(prompt_template, {\n    \"topic\": \"Introduction to Python\",\n    \"learning_level\": \"beginner\"\n})\n\n# Generate content\ncontent = curator.generate_content(prompt)\n\n# Validate the content\nvalidation_result = curator.validate_content(content, validators=[\n    {\"name\": \"readability\", \"parameters\": {\"min_score\": 70}},\n    {\"name\": \"structure\", \"parameters\": {\"required_sections\": [\"objectives\", \"content\"]}}\n])\n\n# Remediate the content if needed\nif not validation_result.passed:\n    content = curator.remediate_content(content, validation_result)\n\n# Save the final content\nwith open(\"output/python_module.md\", \"w\") as f:\n    f.write(content)\n</code></pre>"},{"location":"api/core/#creating-and-saving-a-workflow","title":"Creating and Saving a Workflow","text":"<pre><code>from curriculum_curator.core import create_workflow, save_workflow\n\n# Define a workflow\nworkflow = create_workflow(\n    name=\"Basic Module Generation\",\n    description=\"Generate a module outline with validation\",\n    stages=[\n        {\n            \"name\": \"Generate Module Outline\",\n            \"type\": \"llm_generation\",\n            \"prompt_template\": \"module/outline.txt\",\n            \"parameters\": {\n                \"topic\": \"{topic}\",\n                \"learning_level\": \"{learning_level}\"\n            }\n        },\n        {\n            \"name\": \"Validate Module Outline\",\n            \"type\": \"validation\",\n            \"validators\": [\n                {\n                    \"name\": \"readability\",\n                    \"parameters\": {\n                        \"min_score\": 60\n                    }\n                }\n            ]\n        }\n    ]\n)\n\n# Save the workflow\nsave_workflow(workflow, \"workflows/basic_module.yaml\")\n</code></pre>"},{"location":"api/overview/","title":"API Overview","text":"<p>This section provides an overview of the Curriculum Curator API, its main components, and how they interact.</p>"},{"location":"api/overview/#core-components","title":"Core Components","text":"<p>The Curriculum Curator API is organized into several core modules:</p> <ol> <li>Core: Central orchestration and workflow execution</li> <li>Config: Configuration management and validation</li> <li>Workflow: Workflow definition and execution</li> <li>Prompt: Prompt template management</li> <li>LLM: Language model integration</li> <li>Validation: Content validation framework</li> <li>Remediation: Content remediation framework</li> <li>Persistence: Data storage and retrieval</li> <li>Content: Content transformation utilities</li> </ol>"},{"location":"api/overview/#api-structure","title":"API Structure","text":"<p>The API follows a modular design that separates concerns:</p> <pre><code>curriculum_curator/\n\u251c\u2500\u2500 core.py          # Core orchestration\n\u251c\u2500\u2500 config/          # Configuration management\n\u251c\u2500\u2500 workflow/        # Workflow engine\n\u251c\u2500\u2500 prompt/          # Prompt management\n\u251c\u2500\u2500 llm/             # LLM integration\n\u251c\u2500\u2500 validation/      # Content validation\n\u251c\u2500\u2500 remediation/     # Content remediation\n\u251c\u2500\u2500 persistence/     # Data persistence\n\u2514\u2500\u2500 utils/           # Utility functions\n</code></pre>"},{"location":"api/overview/#key-interfaces","title":"Key Interfaces","text":""},{"location":"api/overview/#workflowengine","title":"WorkflowEngine","text":"<p>The <code>WorkflowEngine</code> is the central component that orchestrates the execution of workflows:</p> <pre><code>class WorkflowEngine:\n    def __init__(self, config, llm_manager=None):\n        \"\"\"Initialize a workflow engine with configuration.\"\"\"\n\n    def load_workflow(self, workflow_path):\n        \"\"\"Load a workflow definition from a file.\"\"\"\n\n    def execute(self, workflow, parameters=None):\n        \"\"\"Execute a workflow with optional parameters.\"\"\"\n\n    def execute_stage(self, stage, content=None):\n        \"\"\"Execute a single workflow stage.\"\"\"\n</code></pre>"},{"location":"api/overview/#validationmanager","title":"ValidationManager","text":"<p>The <code>ValidationManager</code> handles content validation:</p> <pre><code>class ValidationManager:\n    def __init__(self, config=None):\n        \"\"\"Initialize the validation manager.\"\"\"\n\n    def validate(self, content, validators=None):\n        \"\"\"Validate content using specified validators.\"\"\"\n\n    def get_validator(self, name):\n        \"\"\"Get a validator by name.\"\"\"\n</code></pre>"},{"location":"api/overview/#remediationmanager","title":"RemediationManager","text":"<p>The <code>RemediationManager</code> handles automatic content remediation:</p> <pre><code>class RemediationManager:\n    def __init__(self, config=None):\n        \"\"\"Initialize the remediation manager.\"\"\"\n\n    def remediate(self, content, validation_results, remediators=None):\n        \"\"\"Remediate content based on validation results.\"\"\"\n\n    def get_remediator(self, name):\n        \"\"\"Get a remediator by name.\"\"\"\n</code></pre>"},{"location":"api/overview/#promptregistry","title":"PromptRegistry","text":"<p>The <code>PromptRegistry</code> manages prompt templates:</p> <pre><code>class PromptRegistry:\n    def __init__(self, prompt_dirs=None):\n        \"\"\"Initialize the prompt registry.\"\"\"\n\n    def get_prompt(self, template_name):\n        \"\"\"Get a prompt template by name.\"\"\"\n\n    def format_prompt(self, template_name, parameters):\n        \"\"\"Format a prompt template with parameters.\"\"\"\n</code></pre>"},{"location":"api/overview/#llmmanager","title":"LLMManager","text":"<p>The <code>LLMManager</code> provides a unified interface to language models:</p> <pre><code>class LLMManager:\n    def __init__(self, config=None):\n        \"\"\"Initialize the LLM manager.\"\"\"\n\n    def generate(self, prompt, model=None, parameters=None):\n        \"\"\"Generate content using the specified LLM.\"\"\"\n\n    def get_model(self, name):\n        \"\"\"Get a specific LLM model.\"\"\"\n</code></pre>"},{"location":"api/overview/#using-the-api","title":"Using the API","text":""},{"location":"api/overview/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of using the Curriculum Curator API:</p> <pre><code>from curriculum_curator.core import CurriculumCurator\nfrom curriculum_curator.config.utils import load_config\n\n# Load configuration\nconfig = load_config(\"config.yaml\")\n\n# Initialize the curator\ncurator = CurriculumCurator(config)\n\n# Execute a workflow\nresult = curator.execute_workflow(\n    \"workflows/generate_module.yaml\",\n    parameters={\n        \"topic\": \"Introduction to Python\",\n        \"learning_level\": \"beginner\"\n    }\n)\n\n# Access the generated content\nmodule_outline = result.content\n\n# Save the result\ncurator.save_result(result, \"output/python_module.md\")\n</code></pre>"},{"location":"api/overview/#advanced-usage","title":"Advanced Usage","text":"<p>For more advanced usage, you can interact with the individual components directly:</p> <pre><code>from curriculum_curator.workflow.engine import WorkflowEngine\nfrom curriculum_curator.llm.manager import LLMManager\nfrom curriculum_curator.prompt.registry import PromptRegistry\n\n# Initialize components\nllm_manager = LLMManager(config)\nprompt_registry = PromptRegistry()\nworkflow_engine = WorkflowEngine(config, llm_manager=llm_manager)\n\n# Load and execute a workflow\nworkflow = workflow_engine.load_workflow(\"workflows/custom_workflow.yaml\")\nresult = workflow_engine.execute(workflow, {\"topic\": \"Machine Learning\"})\n\n# Validate content separately\nfrom curriculum_curator.validation.manager import ValidationManager\nvalidation_manager = ValidationManager(config)\nvalidation_results = validation_manager.validate(\n    result.content,\n    validators=[\n        {\"name\": \"readability\", \"parameters\": {\"min_score\": 70}}\n    ]\n)\n\n# Remediate content based on validation results\nfrom curriculum_curator.remediation.manager import RemediationManager\nremediation_manager = RemediationManager(config)\nremediated_content = remediation_manager.remediate(\n    result.content,\n    validation_results,\n    remediators=[\n        {\"name\": \"sentence_splitter\", \"parameters\": {\"max_length\": 25}}\n    ]\n)\n</code></pre>"},{"location":"api/overview/#extension-points","title":"Extension Points","text":"<p>The API is designed to be extensible through several key extension points:</p> <ol> <li>Custom Validators: Create your own validators by extending the base <code>Validator</code> class</li> <li>Custom Remediators: Create your own remediators by extending the base <code>Remediator</code> class</li> <li>Custom LLM Providers: Add support for new LLM providers by implementing the <code>LLMProvider</code> interface</li> <li>Custom Storage Backends: Implement custom storage solutions by extending the <code>StorageProvider</code> interface</li> </ol> <p>For more detailed information on specific API components, refer to the dedicated API reference pages.</p>"},{"location":"api/workflow/","title":"Workflow API","text":"<p>The Workflow API provides the components for defining, building, and executing workflows within the Curriculum Curator system.</p>"},{"location":"api/workflow/#workflowengine","title":"WorkflowEngine","text":"<p>The <code>WorkflowEngine</code> class is responsible for executing workflow definitions:</p> <pre><code>from curriculum_curator.workflow.engine import WorkflowEngine\n\nengine = WorkflowEngine(config)\nworkflow = engine.load_workflow(\"workflows/my_workflow.yaml\")\nresult = engine.execute(workflow, parameters={\"topic\": \"Python\"})\n</code></pre>"},{"location":"api/workflow/#class-definition","title":"Class Definition","text":"<pre><code>class WorkflowEngine:\n    \"\"\"\n    Engine for executing workflows defined in YAML configurations.\n\n    The WorkflowEngine is responsible for orchestrating the execution of\n    multi-stage workflows, including content generation, validation,\n    and remediation stages.\n    \"\"\"\n\n    def __init__(self, config=None, llm_manager=None, validation_manager=None, \n                 remediation_manager=None, prompt_registry=None):\n        \"\"\"\n        Initialize a new WorkflowEngine.\n\n        Args:\n            config (dict, optional): Configuration options.\n            llm_manager (LLMManager, optional): LLM manager instance.\n            validation_manager (ValidationManager, optional): Validation manager instance.\n            remediation_manager (RemediationManager, optional): Remediation manager instance.\n            prompt_registry (PromptRegistry, optional): Prompt registry instance.\n        \"\"\"\n\n    def load_workflow(self, workflow_path):\n        \"\"\"\n        Load a workflow definition from a YAML file.\n\n        Args:\n            workflow_path (str): Path to the workflow YAML file.\n\n        Returns:\n            Workflow: The loaded workflow object.\n        \"\"\"\n\n    def execute(self, workflow, parameters=None):\n        \"\"\"\n        Execute a workflow with optional parameters.\n\n        Args:\n            workflow (Workflow): The workflow to execute.\n            parameters (dict, optional): Parameters to pass to the workflow.\n\n        Returns:\n            WorkflowResult: The result of the workflow execution.\n        \"\"\"\n\n    def execute_stage(self, stage, content=None, parameters=None):\n        \"\"\"\n        Execute a single workflow stage.\n\n        Args:\n            stage (Stage): The stage to execute.\n            content (str, optional): Input content for the stage.\n            parameters (dict, optional): Parameters for the stage.\n\n        Returns:\n            tuple: (output_content, stage_result)\n        \"\"\"\n\n    def execute_llm_generation_stage(self, stage, parameters=None):\n        \"\"\"\n        Execute an LLM generation stage.\n\n        Args:\n            stage (Stage): The LLM generation stage to execute.\n            parameters (dict, optional): Parameters for the stage.\n\n        Returns:\n            tuple: (generated_content, stage_result)\n        \"\"\"\n\n    def execute_validation_stage(self, stage, content, parameters=None):\n        \"\"\"\n        Execute a validation stage.\n\n        Args:\n            stage (Stage): The validation stage to execute.\n            content (str): Content to validate.\n            parameters (dict, optional): Parameters for the stage.\n\n        Returns:\n            tuple: (content, validation_result)\n        \"\"\"\n\n    def execute_remediation_stage(self, stage, content, validation_results, parameters=None):\n        \"\"\"\n        Execute a remediation stage.\n\n        Args:\n            stage (Stage): The remediation stage to execute.\n            content (str): Content to remediate.\n            validation_results (ValidationResult): Validation results.\n            parameters (dict, optional): Parameters for the stage.\n\n        Returns:\n            tuple: (remediated_content, remediation_result)\n        \"\"\"\n</code></pre>"},{"location":"api/workflow/#workflowbuilder","title":"WorkflowBuilder","text":"<p>The <code>WorkflowBuilder</code> class provides an interactive way to build workflow definitions:</p> <pre><code>from curriculum_curator.workflow.builder import WorkflowBuilder\n\nbuilder = WorkflowBuilder()\nworkflow = builder.build_interactive()\nbuilder.save_workflow(workflow, \"workflows/new_workflow.yaml\")\n</code></pre>"},{"location":"api/workflow/#class-definition_1","title":"Class Definition","text":"<pre><code>class WorkflowBuilder:\n    \"\"\"\n    Interactive builder for creating workflow definitions.\n\n    The WorkflowBuilder provides a guided approach to creating workflow\n    definitions without requiring manual YAML editing.\n    \"\"\"\n\n    def __init__(self, prompt_registry=None, validator_registry=None, \n                 remediator_registry=None):\n        \"\"\"\n        Initialize a new WorkflowBuilder.\n\n        Args:\n            prompt_registry (PromptRegistry, optional): Prompt registry instance.\n            validator_registry (list, optional): List of available validators.\n            remediator_registry (list, optional): List of available remediators.\n        \"\"\"\n\n    def build_interactive(self):\n        \"\"\"\n        Build a workflow interactively through command-line prompts.\n\n        Returns:\n            Workflow: The created workflow.\n        \"\"\"\n\n    def add_stage_interactive(self, workflow):\n        \"\"\"\n        Add a stage to a workflow interactively.\n\n        Args:\n            workflow (Workflow): The workflow to add a stage to.\n\n        Returns:\n            Stage: The added stage.\n        \"\"\"\n\n    def add_llm_stage_interactive(self):\n        \"\"\"\n        Add an LLM generation stage interactively.\n\n        Returns:\n            Stage: The created LLM generation stage.\n        \"\"\"\n\n    def add_validation_stage_interactive(self):\n        \"\"\"\n        Add a validation stage interactively.\n\n        Returns:\n            Stage: The created validation stage.\n        \"\"\"\n\n    def add_remediation_stage_interactive(self):\n        \"\"\"\n        Add a remediation stage interactively.\n\n        Returns:\n            Stage: The created remediation stage.\n        \"\"\"\n\n    def save_workflow(self, workflow, output_path):\n        \"\"\"\n        Save a workflow to a YAML file.\n\n        Args:\n            workflow (Workflow): The workflow to save.\n            output_path (str): Path where to save the workflow.\n\n        Returns:\n            str: The path where the workflow was saved.\n        \"\"\"\n</code></pre>"},{"location":"api/workflow/#workflow-models","title":"Workflow Models","text":""},{"location":"api/workflow/#workflow","title":"Workflow","text":"<pre><code>class Workflow:\n    \"\"\"\n    Represents a workflow definition.\n\n    A workflow consists of metadata and a sequence of stages to be executed\n    in order.\n\n    Attributes:\n        name (str): Name of the workflow.\n        description (str): Description of the workflow.\n        stages (list): List of Stage objects.\n        metadata (dict): Additional metadata about the workflow.\n    \"\"\"\n\n    def __init__(self, name, description=\"\", stages=None, metadata=None):\n        \"\"\"\n        Initialize a new Workflow.\n\n        Args:\n            name (str): Name of the workflow.\n            description (str, optional): Description of the workflow.\n            stages (list, optional): List of Stage objects.\n            metadata (dict, optional): Additional metadata.\n        \"\"\"\n\n    def add_stage(self, stage):\n        \"\"\"\n        Add a stage to the workflow.\n\n        Args:\n            stage (Stage): The stage to add.\n\n        Returns:\n            Workflow: Self for chaining.\n        \"\"\"\n\n    def to_dict(self):\n        \"\"\"\n        Convert the workflow to a dictionary.\n\n        Returns:\n            dict: Dictionary representation of the workflow.\n        \"\"\"\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Create a Workflow from a dictionary.\n\n        Args:\n            data (dict): Dictionary representation of a workflow.\n\n        Returns:\n            Workflow: The created instance.\n        \"\"\"\n</code></pre>"},{"location":"api/workflow/#stage","title":"Stage","text":"<pre><code>class Stage:\n    \"\"\"\n    Represents a stage in a workflow.\n\n    A stage is a single step in a workflow, such as content generation,\n    validation, or remediation.\n\n    Attributes:\n        name (str): Name of the stage.\n        type (str): Type of the stage (e.g., \"llm_generation\", \"validation\").\n        parameters (dict): Parameters for the stage.\n    \"\"\"\n\n    def __init__(self, name, type_, parameters=None):\n        \"\"\"\n        Initialize a new Stage.\n\n        Args:\n            name (str): Name of the stage.\n            type_ (str): Type of the stage.\n            parameters (dict, optional): Parameters for the stage.\n        \"\"\"\n\n    def to_dict(self):\n        \"\"\"\n        Convert the stage to a dictionary.\n\n        Returns:\n            dict: Dictionary representation of the stage.\n        \"\"\"\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Create a Stage from a dictionary.\n\n        Args:\n            data (dict): Dictionary representation of a stage.\n\n        Returns:\n            Stage: The created instance.\n        \"\"\"\n</code></pre>"},{"location":"api/workflow/#examples","title":"Examples","text":""},{"location":"api/workflow/#defining-a-workflow-programmatically","title":"Defining a Workflow Programmatically","text":"<pre><code>from curriculum_curator.workflow.models import Workflow, Stage\n\n# Create stages\ngenerate_stage = Stage(\n    name=\"Generate Module Outline\",\n    type_=\"llm_generation\",\n    parameters={\n        \"prompt_template\": \"module/outline.txt\",\n        \"parameters\": {\n            \"topic\": \"{topic}\",\n            \"learning_level\": \"{learning_level}\"\n        }\n    }\n)\n\nvalidate_stage = Stage(\n    name=\"Validate Module Outline\",\n    type_=\"validation\",\n    parameters={\n        \"validators\": [\n            {\n                \"name\": \"readability\",\n                \"parameters\": {\n                    \"min_score\": 60\n                }\n            }\n        ]\n    }\n)\n\nremediate_stage = Stage(\n    name=\"Auto-Remediate Issues\",\n    type_=\"remediation\",\n    parameters={\n        \"remediators\": [\n            {\n                \"name\": \"sentence_splitter\",\n                \"parameters\": {\n                    \"max_sentence_length\": 25\n                }\n            }\n        ]\n    }\n)\n\n# Create workflow\nworkflow = Workflow(\n    name=\"Basic Module Generation\",\n    description=\"Generate module outline with validation and remediation\",\n    stages=[generate_stage, validate_stage, remediate_stage],\n    metadata={\n        \"version\": \"1.0\",\n        \"author\": \"Curriculum Curator Team\"\n    }\n)\n\n# Convert to dictionary for serialization\nworkflow_dict = workflow.to_dict()\n</code></pre>"},{"location":"api/workflow/#using-the-workflow-engine","title":"Using the Workflow Engine","text":"<pre><code>from curriculum_curator.workflow.engine import WorkflowEngine\nfrom curriculum_curator.llm.manager import LLMManager\nfrom curriculum_curator.validation.manager import ValidationManager\nfrom curriculum_curator.remediation.manager import RemediationManager\nfrom curriculum_curator.prompt.registry import PromptRegistry\nfrom curriculum_curator.config.utils import load_config\n\n# Load configuration\nconfig = load_config(\"config.yaml\")\n\n# Initialize components\nllm_manager = LLMManager(config)\nvalidation_manager = ValidationManager(config)\nremediation_manager = RemediationManager(config)\nprompt_registry = PromptRegistry()\n\n# Initialize the workflow engine\nengine = WorkflowEngine(\n    config=config,\n    llm_manager=llm_manager,\n    validation_manager=validation_manager,\n    remediation_manager=remediation_manager,\n    prompt_registry=prompt_registry\n)\n\n# Load a workflow\nworkflow = engine.load_workflow(\"workflows/module_generation.yaml\")\n\n# Execute the workflow\nresult = engine.execute(\n    workflow,\n    parameters={\n        \"topic\": \"Machine Learning Basics\",\n        \"learning_level\": \"intermediate\"\n    }\n)\n\n# Process the result\nprint(f\"Workflow '{result.workflow_name}' executed successfully.\")\nprint(f\"Content length: {len(result.content)} characters\")\nif hasattr(result, 'validation_results'):\n    print(f\"Validation passed: {result.validation_results.passed}\")\n</code></pre>"},{"location":"api/workflow/#interactive-workflow-building","title":"Interactive Workflow Building","text":"<pre><code>from curriculum_curator.workflow.builder import WorkflowBuilder\nfrom curriculum_curator.prompt.registry import PromptRegistry\n\n# Initialize components\nprompt_registry = PromptRegistry()\nbuilder = WorkflowBuilder(prompt_registry=prompt_registry)\n\n# Build a workflow interactively\nworkflow = builder.build_interactive()\n\n# Save the workflow\nbuilder.save_workflow(workflow, \"workflows/custom_workflow.yaml\")\n</code></pre>"},{"location":"concepts/architecture/","title":"Architecture Overview","text":"<p>Curriculum Curator is built around a modular architecture designed to provide flexibility, extensibility, and maintainability. This document provides a high-level overview of the system architecture.</p>"},{"location":"concepts/architecture/#core-components","title":"Core Components","text":"<p>The system is comprised of several core components that work together:</p> <pre><code>graph TD\n    A[CLI] --&gt; B[CurriculumCurator Core]\n    B --&gt; C[Workflow Engine]\n    B --&gt; D[Prompt Registry]\n    B --&gt; E[LLM Manager]\n    B --&gt; F[Validation Manager]\n    B --&gt; G[Remediation Manager]\n    B --&gt; H[Persistence Manager]\n    C --&gt; I[Workflow Execution]\n    D --&gt; J[Prompt Templates]\n    E --&gt; K[LLM Providers]\n    F --&gt; L[Validators]\n    G --&gt; M[Remediators]\n    H --&gt; N[Session Storage]\n</code></pre>"},{"location":"concepts/architecture/#cli","title":"CLI","text":"<p>The Command Line Interface (CLI) provides the entry point for users to interact with the system. It offers commands for running workflows, managing prompts, building workflows, and more.</p>"},{"location":"concepts/architecture/#core","title":"Core","text":"<p>The <code>CurriculumCurator</code> core class orchestrates the interaction between all components, managing the lifecycle of workflow execution and ensuring all components work together seamlessly.</p>"},{"location":"concepts/architecture/#workflow-engine","title":"Workflow Engine","text":"<p>The Workflow Engine is responsible for parsing workflow configurations, validating them against schemas, and executing the workflows step by step.</p>"},{"location":"concepts/architecture/#prompt-registry","title":"Prompt Registry","text":"<p>The Prompt Registry manages the collection of prompt templates, handling their loading, parsing of front matter metadata, and making them available to the workflow engine.</p>"},{"location":"concepts/architecture/#llm-manager","title":"LLM Manager","text":"<p>The LLM Manager provides a unified interface to different Language Model providers (Anthropic, OpenAI, Ollama, etc.), handling API communication, token tracking, and error handling.</p>"},{"location":"concepts/architecture/#validation-manager","title":"Validation Manager","text":"<p>The Validation Manager coordinates content validation using various validators for quality checks, ensuring content meets the specified criteria.</p>"},{"location":"concepts/architecture/#remediation-manager","title":"Remediation Manager","text":"<p>The Remediation Manager handles the automated fixing of issues identified during validation, using various remediators to improve content quality.</p>"},{"location":"concepts/architecture/#persistence-manager","title":"Persistence Manager","text":"<p>The Persistence Manager handles session state persistence, allowing workflows to be paused and resumed, and providing a record of completed workflows.</p>"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":"<p>The typical data flow in Curriculum Curator is:</p> <ol> <li>User runs a workflow through the CLI</li> <li>Workflow Engine loads and validates the workflow configuration</li> <li>Workflow Engine executes each step:</li> <li>Prompt steps: Load prompts from Prompt Registry, send to LLM through LLM Manager</li> <li>Validation steps: Pass content to Validation Manager for quality checks</li> <li>Remediation steps: Pass content and issues to Remediation Manager for fixing</li> <li>Output steps: Write content to output files</li> <li>Persistence Manager tracks the workflow state throughout execution</li> <li>Results are returned to the user (CLI or interactive interface)</li> </ol>"},{"location":"concepts/architecture/#key-design-principles","title":"Key Design Principles","text":""},{"location":"concepts/architecture/#1-configuration-driven","title":"1. Configuration-Driven","text":"<p>Workflow behavior is defined through configuration rather than code, allowing users to create complex workflows without programming.</p>"},{"location":"concepts/architecture/#2-modular-components","title":"2. Modular Components","text":"<p>Components are designed to be pluggable and replaceable, with well-defined interfaces between them.</p>"},{"location":"concepts/architecture/#3-extensibility","title":"3. Extensibility","text":"<p>The system is designed to be extended with new validators, remediators, and LLM providers with minimal code changes.</p>"},{"location":"concepts/architecture/#4-progressive-disclosure","title":"4. Progressive Disclosure","text":"<p>The system provides multiple interfaces, from simple CLI commands to interactive menus, allowing users to discover features gradually.</p>"},{"location":"concepts/architecture/#interactive-components","title":"Interactive Components","text":"<p>In addition to the core components, the system includes interactive components for a more user-friendly experience:</p> <ul> <li>Interactive Mode: A top-level menu-driven interface for all operations</li> <li>Workflow Builder: A guided interface for creating and editing workflow configurations</li> <li>Prompt Editor: An interface for creating and editing prompt templates with validation</li> </ul>"},{"location":"concepts/architecture/#folder-structure","title":"Folder Structure","text":"<p>The package is organized into modules that correspond to the major components:</p> <pre><code>curriculum_curator/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 cli.py                 # Command-line interface\n\u251c\u2500\u2500 core.py                # Core orchestration\n\u251c\u2500\u2500 config/                # Configuration handling\n\u251c\u2500\u2500 workflow/              # Workflow engine\n\u251c\u2500\u2500 prompt/                # Prompt registry\n\u251c\u2500\u2500 llm/                   # LLM manager\n\u251c\u2500\u2500 validation/            # Validation framework\n\u2502   \u2514\u2500\u2500 validators/        # Validator implementations\n\u251c\u2500\u2500 remediation/           # Remediation framework\n\u2502   \u2514\u2500\u2500 remediators/       # Remediator implementations\n\u251c\u2500\u2500 persistence/           # Session persistence\n\u2514\u2500\u2500 utils/                 # Utility functions\n</code></pre>"},{"location":"concepts/architecture/#further-reading","title":"Further Reading","text":"<ul> <li>ADR-0002: Validation and Remediation Design</li> <li>ADR-0003: Workflow Configuration Format</li> <li>ADR-0005: Interactive Interfaces</li> </ul>"},{"location":"concepts/prompts/","title":"Prompts","text":"<p>Prompts are the instructions given to language models (LLMs) to generate educational content within the Curriculum Curator system.</p>"},{"location":"concepts/prompts/#overview","title":"Overview","text":"<p>Prompts in Curriculum Curator are structured templates that guide LLMs to produce specific types of educational content. The system uses a prompt registry to organize and manage these templates, making them accessible across workflows.</p>"},{"location":"concepts/prompts/#prompt-templates","title":"Prompt Templates","text":"<p>Prompt templates are stored as text files with special placeholders for dynamic content. These placeholders are replaced with actual values when the prompt is used in a workflow.</p> <p>Example prompt template for generating a module outline:</p> <pre><code>Create a detailed outline for a module on {topic} appropriate for {learning_level} students.\n\nThe outline should include:\n- Learning objectives (3-5)\n- Key topics and subtopics (5-7)\n- Suggested activities (2-3)\n- Assessment methods\n\nFormat the outline with clear hierarchical structure using markdown syntax.\nEnsure all content is factually accurate and pedagogically sound.\n</code></pre>"},{"location":"concepts/prompts/#prompt-registry","title":"Prompt Registry","text":"<p>The prompt registry is a central repository for all prompt templates in the system. It:</p> <ul> <li>Organizes prompts by category and purpose</li> <li>Provides versioning for prompt templates</li> <li>Allows sharing and reuse of effective prompts</li> <li>Supports loading prompts from files or embedded resources</li> </ul>"},{"location":"concepts/prompts/#prompt-parameters","title":"Prompt Parameters","text":"<p>Prompts can include parameters that are populated when the prompt is used:</p> <ul> <li>Topic parameters (e.g., \"Machine Learning\", \"Ancient Rome\")</li> <li>Learning level parameters (e.g., \"beginner\", \"advanced\")</li> <li>Format parameters (e.g., \"outline\", \"detailed notes\")</li> <li>Educational context parameters (e.g., \"high school\", \"university\")</li> </ul>"},{"location":"concepts/prompts/#interactive-prompt-editor","title":"Interactive Prompt Editor","text":"<p>Curriculum Curator provides an interactive prompt editor that allows you to:</p> <ol> <li>Create new prompt templates</li> <li>Edit existing templates</li> <li>Test prompts with sample parameters</li> <li>Preview generated content</li> <li>Save and version prompt templates</li> </ol> <p>For more information, see the Prompt Editor Guide.</p>"},{"location":"concepts/prompts/#best-practices","title":"Best Practices","text":"<p>When creating prompts for educational content:</p> <ul> <li>Be specific about the expected output format</li> <li>Include clear instructions about learning objectives</li> <li>Specify the target audience and their background knowledge</li> <li>Include guidelines for pedagogical approaches</li> <li>Request appropriate depth and breadth of coverage</li> <li>Specify any educational standards or frameworks to consider</li> </ul>"},{"location":"concepts/prompts/#prompt-categories","title":"Prompt Categories","text":"<p>The system organizes prompts into several categories:</p> <ul> <li>Course: High-level course design prompts</li> <li>Module: Module and unit design prompts</li> <li>Lecture: Lecture content generation prompts</li> <li>Assessment: Quiz, test, and assessment prompts</li> <li>Instructor: Instructor guides and teaching notes</li> <li>Worksheet: Student activity and worksheet prompts</li> </ul> <p>Each category has specialized prompts designed for specific educational content types.</p>"},{"location":"concepts/remediation/","title":"Remediation","text":"<p>Remediation is the process of automatically fixing or improving educational content based on validation results in the Curriculum Curator system.</p>"},{"location":"concepts/remediation/#overview","title":"Overview","text":"<p>The remediation system in Curriculum Curator provides automated correction of content issues detected during validation. It helps improve content quality without manual intervention, streamlining the content creation pipeline.</p>"},{"location":"concepts/remediation/#remediation-manager","title":"Remediation Manager","text":"<p>The Remediation Manager orchestrates the remediation process by:</p> <ol> <li>Loading appropriate remediators based on configuration</li> <li>Applying remediators to content with validation issues</li> <li>Tracking changes made to the content</li> <li>Providing detailed reports on remediation actions</li> </ol>"},{"location":"concepts/remediation/#remediator-types","title":"Remediator Types","text":"<p>The system includes multiple types of remediators, each addressing different aspects of content improvement:</p>"},{"location":"concepts/remediation/#autofix-remediators","title":"AutoFix Remediators","text":"<ul> <li>Format Corrector: Fixes formatting issues like inconsistent headers, lists, and spacing</li> <li>Sentence Splitter: Breaks long sentences into shorter, more readable ones</li> <li>Terminology Enforcer: Ensures consistent use of terminology according to glossaries</li> </ul>"},{"location":"concepts/remediation/#language-remediators","title":"Language Remediators","text":"<ul> <li>Translator: Translates content to a different language</li> <li>Style Adjuster: Modifies writing style to match target audience</li> </ul>"},{"location":"concepts/remediation/#rewrite-remediators","title":"Rewrite Remediators","text":"<ul> <li>Rephrasing Prompter: Uses LLMs to rewrite problematic sections while preserving meaning</li> <li>Simplifier: Reduces complexity for specified reading levels</li> </ul>"},{"location":"concepts/remediation/#workflow-remediators","title":"Workflow Remediators","text":"<ul> <li>Flag for Review: Marks content for human review when automated fixes aren't possible</li> <li>Escalation: Routes content to specialized workflows based on specific issues</li> </ul>"},{"location":"concepts/remediation/#remediation-configuration","title":"Remediation Configuration","text":"<p>Remediators are configured in workflow YAML files:</p> <pre><code>stages:\n  - name: \"Auto-Remediate Content Issues\"\n    type: \"remediation\"\n    remediators:\n      - name: \"sentence_splitter\"\n        parameters:\n          max_sentence_length: 25\n          preserve_technical_terms: true\n\n      - name: \"format_corrector\"\n        parameters:\n          fix_headers: true\n          fix_lists: true\n\n      - name: \"rephrasing_prompter\"\n        parameters:\n          severity_threshold: \"high\"\n          preserve_technical_accuracy: true\n</code></pre>"},{"location":"concepts/remediation/#remediation-process","title":"Remediation Process","text":"<p>When remediation is triggered:</p> <ol> <li>The system analyzes validation results to identify issues</li> <li>It selects appropriate remediators based on the issue types</li> <li>Remediators are applied in a configured order</li> <li>Changes are tracked and recorded</li> <li>Content is optionally re-validated to ensure issues are resolved</li> </ol>"},{"location":"concepts/remediation/#custom-remediators","title":"Custom Remediators","text":"<p>The system supports creating custom remediators by:</p> <ol> <li>Implementing the base Remediator interface</li> <li>Registering the remediator with the system</li> <li>Configuring the remediator in workflows</li> </ol>"},{"location":"concepts/remediation/#integration-with-validation","title":"Integration with Validation","text":"<p>Remediation works closely with the validation system, using validation results to target specific issues. This creates a powerful pipeline where content can be continuously improved through iterative validation and remediation.</p> <p>For more information on how validation and remediation work together, see ADR-0002: Validation and Remediation Design.</p>"},{"location":"concepts/remediation/#remediation-in-workflows","title":"Remediation in Workflows","text":"<p>Remediation is typically included as a specific stage in workflows, often following validation. This ensures that content issues are systematically addressed before proceeding to further processing or delivery stages.</p>"},{"location":"concepts/remediation/#human-in-the-loop-remediation","title":"Human-in-the-Loop Remediation","text":"<p>For complex issues that can't be fully automated, the system supports human-in-the-loop remediation where:</p> <ol> <li>Automated fixes are applied where possible</li> <li>Complex issues are flagged for human review</li> <li>Suggestions are provided to guide human editors</li> <li>Manual changes are recorded for future learning</li> </ol>"},{"location":"concepts/validation/","title":"Validation","text":"<p>Validation is the process of assessing educational content against predetermined quality criteria in the Curriculum Curator system.</p>"},{"location":"concepts/validation/#overview","title":"Overview","text":"<p>The validation system in Curriculum Curator provides automated quality checks for educational content. It helps ensure that generated or imported content meets specific standards before being used in educational materials.</p>"},{"location":"concepts/validation/#validation-manager","title":"Validation Manager","text":"<p>The Validation Manager orchestrates the validation process by:</p> <ol> <li>Loading appropriate validators based on configuration</li> <li>Running validators against content</li> <li>Collecting and organizing validation results</li> <li>Providing feedback on issues found</li> </ol>"},{"location":"concepts/validation/#validator-types","title":"Validator Types","text":"<p>The system includes multiple types of validators, each focusing on different aspects of educational content:</p>"},{"location":"concepts/validation/#quality-validators","title":"Quality Validators","text":"<ul> <li>Readability: Assesses content readability using metrics like Flesch-Kincaid</li> <li>Structure: Checks for proper hierarchical structure in content</li> <li>Similarity: Compares content against reference materials to ensure originality</li> </ul>"},{"location":"concepts/validation/#language-validators","title":"Language Validators","text":"<ul> <li>Language Detection: Ensures content is in the expected language</li> <li>Terminology: Verifies that domain-specific terminology is used correctly</li> </ul>"},{"location":"concepts/validation/#alignment-validators","title":"Alignment Validators","text":"<ul> <li>Learning Objective Alignment: Checks that content aligns with stated learning objectives</li> <li>Curriculum Standards: Validates against educational standards or frameworks</li> </ul>"},{"location":"concepts/validation/#safety-validators","title":"Safety Validators","text":"<ul> <li>Content Safety: Checks for inappropriate, harmful, or biased content</li> <li>Factual Accuracy: Flags potentially incorrect information</li> </ul>"},{"location":"concepts/validation/#validation-configuration","title":"Validation Configuration","text":"<p>Validators are configured in workflow YAML files:</p> <pre><code>stages:\n  - name: \"Validate Module Content\"\n    type: \"validation\"\n    validators:\n      - name: \"readability\"\n        parameters:\n          min_score: 60\n          target_audience: \"undergraduate\"\n\n      - name: \"structure\"\n        parameters:\n          required_sections: [\"objectives\", \"content\", \"assessment\"]\n\n      - name: \"language_detector\"\n        parameters:\n          expected_language: \"en\"\n</code></pre>"},{"location":"concepts/validation/#validation-results","title":"Validation Results","text":"<p>Validation produces structured results that include:</p> <ul> <li>Overall pass/fail status</li> <li>Individual validator results</li> <li>Specific issues detected</li> <li>Severity levels for issues</li> <li>Suggestions for improvement</li> </ul>"},{"location":"concepts/validation/#custom-validators","title":"Custom Validators","text":"<p>The system supports creating custom validators by:</p> <ol> <li>Implementing the base Validator interface</li> <li>Registering the validator with the system</li> <li>Configuring the validator in workflows</li> </ol>"},{"location":"concepts/validation/#integration-with-remediation","title":"Integration with Remediation","text":"<p>Validation results can be directly fed into the remediation system for automatic fixing of detected issues. This creates a powerful pipeline where content can be continuously improved through iterative validation and remediation.</p> <p>For more information on how validation and remediation work together, see ADR-0002: Validation and Remediation Design.</p>"},{"location":"concepts/validation/#validation-in-workflows","title":"Validation in Workflows","text":"<p>Validation is typically included as a specific stage in workflows, often following content generation and preceding remediation. This ensures that content quality is systematically assessed before proceeding to further processing or delivery stages.</p>"},{"location":"concepts/workflows/","title":"Workflows","text":"<p>Workflows are the central concept in Curriculum Curator, representing a sequence of processing steps applied to educational content.</p>"},{"location":"concepts/workflows/#overview","title":"Overview","text":"<p>A workflow is a configurable pipeline of operations that can transform, validate, and remediate educational content. Workflows allow you to define how content moves through your educational content creation pipeline, from initial drafts to final publication.</p>"},{"location":"concepts/workflows/#key-components","title":"Key Components","text":""},{"location":"concepts/workflows/#workflow-definition","title":"Workflow Definition","text":"<p>Workflows are defined using YAML configuration files. A typical workflow includes:</p> <ul> <li>Metadata: Information about the workflow itself</li> <li>Stages: Ordered sequence of processing steps</li> <li>Validation Rules: Criteria for content quality assessment</li> <li>Remediation Actions: Automatic fixes for common issues</li> </ul> <p>Example workflow configuration:</p> <pre><code>name: \"Basic Module Generation\"\ndescription: \"Generate module outline with validation\"\n\nstages:\n  - name: \"Generate Module Outline\"\n    type: \"llm_generation\"\n    prompt_template: \"module/outline.txt\"\n    parameters:\n      topic: \"{topic}\"\n      learning_level: \"{learning_level}\"\n\n  - name: \"Validate Module Outline\"\n    type: \"validation\"\n    validators:\n      - name: \"readability\"\n        parameters:\n          min_score: 60\n\n  - name: \"Auto-Remediate Issues\"\n    type: \"remediation\"\n    remediators:\n      - name: \"sentence_splitter\"\n        parameters:\n          max_sentence_length: 25\n</code></pre>"},{"location":"concepts/workflows/#workflow-execution","title":"Workflow Execution","text":"<p>When a workflow is executed:</p> <ol> <li>Each stage is processed in order</li> <li>Content flows from one stage to the next</li> <li>Validation stages check content against rules</li> <li>Remediation stages attempt to fix detected issues</li> <li>Results are stored according to the configuration</li> </ol>"},{"location":"concepts/workflows/#interactive-workflow-builder","title":"Interactive Workflow Builder","text":"<p>The Curriculum Curator provides an interactive workflow builder tool that allows you to create and edit workflows through a guided interface without manually editing YAML files. For more information, see the Workflow Builder Guide.</p>"},{"location":"concepts/workflows/#pre-defined-workflows","title":"Pre-defined Workflows","text":"<p>The system comes with several pre-defined workflows that address common education content creation needs:</p> <ul> <li>Minimal Module Workflow: Basic module generation with minimal validation</li> <li>Comprehensive Course Workflow: Complete course creation with all content types</li> <li>Assessment Generation Workflow: Focused on creating varied assessments</li> </ul>"},{"location":"concepts/workflows/#custom-workflows","title":"Custom Workflows","text":"<p>You can create custom workflows by:</p> <ol> <li>Starting with an existing workflow template</li> <li>Creating a new workflow from scratch</li> <li>Using the interactive workflow builder</li> <li>Manually creating a workflow YAML file</li> </ol> <p>For more information on creating a basic workflow, see the MVP Workflow Guide.</p>"},{"location":"development/contributing/","title":"Contributing to Curriculum Curator","text":"<p>Thank you for your interest in contributing to Curriculum Curator! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Git</li> </ul>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/your-username/curriculum-curator.git\ncd curriculum-curator\n</code></pre></p> </li> <li> <p>Install the package in development mode:    <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branching","title":"Branching","text":"<ul> <li><code>main</code> branch is the stable version</li> <li>Create feature branches from <code>main</code> for your work</li> <li>Use a descriptive name for your branch, e.g., <code>feature/workflow-builder</code> or <code>fix/validation-issue</code></li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>Run tests with pytest:</p> <pre><code>pytest\n</code></pre> <p>To run tests with coverage:</p> <pre><code>pytest --cov=curriculum_curator\n</code></pre>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>We use several tools to ensure code quality:</p> <ul> <li>Ruff: For linting and formatting</li> <li>Mypy: For type checking</li> <li>Pre-commit: To run checks before committing</li> </ul> <p>Run pre-commit on all files:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update documentation for any new features or changes</li> <li>Run the documentation site locally:   <pre><code>mkdocs serve\n</code></pre></li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a pull request from your feature branch to the <code>main</code> branch</li> <li>Ensure all tests pass and the code meets style guidelines</li> <li>Update documentation as needed</li> <li>Add a clear description of the changes in the pull request</li> <li>Request a review from at least one maintainer</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<ol> <li>Update the version number in <code>pyproject.toml</code></li> <li>Update the CHANGELOG.md file</li> <li>Create a git tag for the version</li> <li>Build the package</li> <li>Upload to PyPI</li> </ol> <p>See the PyPI publishing guide for detailed instructions.</p>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<p>Understanding where to make changes is important. Here's a quick guide to the project structure:</p> <ul> <li><code>curriculum_curator/</code>: Main package</li> <li><code>cli.py</code>: Command-line interface</li> <li><code>core.py</code>: Core functionality</li> <li><code>config/</code>: Configuration handling</li> <li><code>workflow/</code>: Workflow engine</li> <li><code>prompt/</code>: Prompt registry</li> <li><code>llm/</code>: LLM integration</li> <li><code>validation/</code>: Content validation<ul> <li><code>validators/</code>: Individual validators</li> </ul> </li> <li><code>remediation/</code>: Content remediation<ul> <li><code>remediators/</code>: Individual remediators</li> </ul> </li> <li><code>persistence/</code>: Session persistence</li> <li><code>utils/</code>: Utility functions</li> <li><code>tests/</code>: Test suite</li> <li><code>docs/</code>: Documentation</li> <li><code>prompts/</code>: Example prompts</li> <li><code>examples/</code>: Example configurations and workflows</li> </ul>"},{"location":"development/contributing/#adding-new-components","title":"Adding New Components","text":""},{"location":"development/contributing/#adding-a-new-validator","title":"Adding a New Validator","text":"<ol> <li>Create a new file in <code>curriculum_curator/validation/validators/[category]/your_validator.py</code></li> <li>Implement a class that extends <code>BaseValidator</code></li> <li>Add your validator to the registry in <code>curriculum_curator/validation/validators/__init__.py</code></li> <li>Add tests in <code>tests/validation/validators/test_your_validator.py</code></li> </ol>"},{"location":"development/contributing/#adding-a-new-remediator","title":"Adding a New Remediator","text":"<ol> <li>Create a new file in <code>curriculum_curator/remediation/remediators/[category]/your_remediator.py</code></li> <li>Implement a class that extends <code>BaseRemediator</code></li> <li>Add your remediator to the registry in <code>curriculum_curator/remediation/remediators/__init__.py</code></li> <li>Add tests in <code>tests/remediation/remediators/test_your_remediator.py</code></li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<p>If you have questions or need help with contributing, please:</p> <ol> <li>Check the existing documentation</li> <li>Open an issue on GitHub if you find a bug or have a feature request</li> <li>Ask for clarification in an existing issue if needed</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Curriculum Curator is a Python package that can be installed using pip. This guide will help you set up the package and its dependencies.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting-started/installation/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The simplest way to install Curriculum Curator is directly from PyPI:</p> <pre><code>pip install curriculum-curator\n</code></pre> <p>This will install the package along with all its dependencies.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to the development of Curriculum Curator, or use the latest development version, you can install it directly from the repository:</p> <pre><code>git clone https://github.com/teaching-repositories/curriculum-curator.git\ncd curriculum-curator\npip install -e \".[dev]\"\n</code></pre> <p>The <code>-e</code> flag installs the package in \"editable\" mode, allowing you to make changes to the code without having to reinstall. The <code>[dev]</code> extra installs development dependencies like pytest, ruff, and mypy.</p>"},{"location":"getting-started/installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>After installation, you can verify that the package is correctly installed by running:</p> <pre><code>curator --version\n</code></pre> <p>You should see the version number of the installed package.</p>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":"<p>After installation, you'll need to configure the package with your LLM API credentials. You can do this by:</p> <ol> <li>Creating a <code>config.yaml</code> file in your project directory:</li> </ol> <pre><code># LLM Configuration\nllm:\n  default:\n    type: openai\n    model: gpt-4-turbo\n    api_key: your-api-key-here\n\n  default_smart:\n    type: anthropic\n    model: claude-3-opus-20240229\n    api_key: your-api-key-here\n\n# Base paths\nprompt_path: prompts/\noutput_path: output/\n</code></pre> <ol> <li>Alternatively, you can set environment variables for the API keys:</li> </ol> <pre><code>export OPENAI_API_KEY=your-api-key-here\nexport ANTHROPIC_API_KEY=your-api-key-here\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once you have Curriculum Curator installed and configured, you can:</p> <ul> <li>Get started with a quick tutorial</li> <li>Learn about the interactive interface</li> <li>Explore the workflow builder</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get up and running with Curriculum Curator in just a few minutes. We'll walk through initializing a project, running a simple workflow, and exploring the interactive interface.</p>"},{"location":"getting-started/quick-start/#initialize-a-project","title":"Initialize a Project","text":"<p>After installing Curriculum Curator, the first step is to initialize a project:</p> <pre><code>curator init\n</code></pre> <p>This will create a basic directory structure in your current directory, including:</p> <ul> <li><code>prompts/</code> - Directory for prompt templates</li> <li><code>output/</code> - Directory for generated content</li> <li><code>config.yaml</code> - Default configuration file</li> </ul>"},{"location":"getting-started/quick-start/#configure-llm-providers","title":"Configure LLM Providers","text":"<p>Edit the <code>config.yaml</code> file to add your API keys for the LLM providers you want to use. At minimum, you'll need one provider configured:</p> <pre><code># LLM Configuration\nllm:\n  default:\n    type: openai\n    model: gpt-4-turbo\n    # Uncomment and add your API key if not set in environment\n    # api_key: your-api-key-here\n</code></pre> <p>You can either add your API key directly in the config file, or set it as an environment variable (recommended):</p> <pre><code>export OPENAI_API_KEY=your-api-key-here\n</code></pre>"},{"location":"getting-started/quick-start/#run-a-built-in-workflow","title":"Run a Built-in Workflow","text":"<p>Curriculum Curator comes with a few built-in workflows. Let's try the <code>minimal_educational_module</code> workflow:</p> <pre><code>curator run minimal_educational_module \\\n  --var course_title=\"Introduction to Python Programming\" \\\n  --var course_slug=\"intro-python\" \\\n  --var module_id=\"module1\" \\\n  --var num_modules=4 \\\n  --var \"learning_objectives=Understand Python basics;Write simple programs\"\n</code></pre> <p>This will: 1. Generate a course overview 2. Create a module outline 3. Produce lecture content for the module 4. Generate a worksheet with practice activities 5. Create an assessment with various question types 6. Build an instructor guide with teaching suggestions</p> <p>The output files will be saved to the <code>output/</code> directory.</p>"},{"location":"getting-started/quick-start/#using-the-interactive-mode","title":"Using the Interactive Mode","text":"<p>For a more user-friendly experience, try the interactive mode:</p> <pre><code>curator interactive\n</code></pre> <p>This launches a menu-driven interface that provides access to all Curriculum Curator functionality, including:</p> <ul> <li>Running workflows</li> <li>Building and editing workflows</li> <li>Editing prompts</li> <li>Initializing projects</li> </ul>"},{"location":"getting-started/quick-start/#exploring-available-workflows","title":"Exploring Available Workflows","text":"<p>To see which workflows are available:</p> <pre><code>curator list-workflows\n</code></pre> <p>This will show both built-in workflows and any custom workflows defined in your configuration.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics, you might want to explore:</p> <ul> <li>How to use the interactive mode for a more guided experience</li> <li>Creating workflows with the workflow builder</li> <li>Editing and creating prompts</li> <li>Understanding the MVP workflow</li> <li>Exploring all CLI commands</li> </ul>"},{"location":"guides/","title":"Curriculum Curator Guides","text":"<p>This directory contains guides for using and contributing to Curriculum Curator.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":"<ul> <li>Interactive Mode Guide: Using the comprehensive menu-driven interface</li> <li>Workflow Builder Guide: How to use the interactive workflow builder</li> <li>Prompt Editor Guide: How to use the interactive prompt editor</li> <li>MVP Workflow Guide: Details on using and extending the MVP workflow</li> <li>Workflow Validation Guide: How to validate workflow configurations</li> <li>CLI Reference: Complete reference for command-line interface commands</li> <li>Publishing to PyPI: How to build and publish the package to PyPI</li> </ul>"},{"location":"guides/#coming-soon","title":"Coming Soon","text":"<ul> <li>Getting Started: Basic usage guide for new users</li> <li>Writing Prompts: Guidelines for creating effective prompts</li> <li>Creating Custom Validators: How to create custom content validators</li> <li>Configuration: Detailed guide to configuration options</li> </ul>"},{"location":"guides/cli-reference/","title":"Curriculum Curator CLI Reference","text":"<p>This document provides a reference for all available Curriculum Curator command-line interface (CLI) commands and options.</p>"},{"location":"guides/cli-reference/#command-overview","title":"Command Overview","text":"Command Description <code>interactive</code> Launch interactive mode with a menu of common operations <code>run</code> Run a specified workflow <code>resume</code> Resume a previously interrupted workflow session <code>list-workflows</code> List all available workflows <code>list-prompts</code> List available prompts, optionally filtered by tag <code>list-validators</code> List available content validators <code>list-remediators</code> List available content remediators <code>build-workflow</code> Interactive workflow builder for creating/editing workflow configurations <code>edit-prompt</code> Interactive prompt editor for creating/editing prompt templates <code>init</code> Initialize a new project with example configuration and prompts"},{"location":"guides/cli-reference/#general-options","title":"General Options","text":"<p>These options are available in most commands:</p> Option Description <code>--config</code>, <code>-c</code> Path to configuration file (default: config.yaml) <code>--help</code> Show help message and exit"},{"location":"guides/cli-reference/#command-details","title":"Command Details","text":""},{"location":"guides/cli-reference/#run-a-workflow","title":"Run a Workflow","text":"<p>Run a specified workflow with optional variables.</p> <pre><code>curator run [OPTIONS] WORKFLOW\n</code></pre> <p>Arguments: - <code>WORKFLOW</code>: Name of the workflow to run (required)</p> <p>Options: - <code>--var</code>, <code>-v</code>: Variables in key=value format. Can be used multiple times - <code>--session-id</code>: Specify a session ID to use or resume - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml) - <code>--output-json</code>, <code>-j</code>: Output result as JSON instead of rich text format</p> <p>Examples: <pre><code># Run a workflow with variables\ncurator run minimal_educational_module --var course_title=\"Python Programming\" --var module_id=\"1\"\n\n# Run with custom configuration file\ncurator run standard_course --config custom_config.yaml\n\n# Run with JSON output\ncurator run minimal_educational_module --output-json &gt; output.json\n</code></pre></p>"},{"location":"guides/cli-reference/#resume-a-workflow","title":"Resume a Workflow","text":"<p>Resume a previously interrupted workflow session.</p> <pre><code>curator resume [OPTIONS] SESSION_ID\n</code></pre> <p>Arguments: - <code>SESSION_ID</code>: The Session ID of the workflow to resume (required)</p> <p>Options: - <code>--from-step</code>: Specific step name to resume from - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml) - <code>--output-json</code>, <code>-j</code>: Output result as JSON</p> <p>Examples: <pre><code># Resume a workflow session\ncurator resume 2023-04-05-12345-abc123\n\n# Resume from a specific step\ncurator resume 2023-04-05-12345-abc123 --from-step validate_content\n</code></pre></p>"},{"location":"guides/cli-reference/#list-workflows","title":"List Workflows","text":"<p>List all available workflows defined in the configuration file and predefined workflows.</p> <pre><code>curator list-workflows [OPTIONS]\n</code></pre> <p>Options: - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml)</p> <p>Example: <pre><code>curator list-workflows\n</code></pre></p>"},{"location":"guides/cli-reference/#list-prompts","title":"List Prompts","text":"<p>List available prompts, optionally filtered by tag.</p> <pre><code>curator list-prompts [OPTIONS]\n</code></pre> <p>Options: - <code>--tag</code>, <code>-t</code>: Filter prompts by tag specified in YAML front matter - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml)</p> <p>Examples: <pre><code># List all prompts\ncurator list-prompts\n\n# List prompts with a specific tag\ncurator list-prompts --tag course\n</code></pre></p>"},{"location":"guides/cli-reference/#list-validators","title":"List Validators","text":"<p>List available content validators that can be used in workflows.</p> <pre><code>curator list-validators\n</code></pre> <p>Example: <pre><code>curator list-validators\n</code></pre></p>"},{"location":"guides/cli-reference/#list-remediators","title":"List Remediators","text":"<p>List available content remediators that can be used in workflows.</p> <pre><code>curator list-remediators\n</code></pre> <p>Example: <pre><code>curator list-remediators\n</code></pre></p>"},{"location":"guides/cli-reference/#build-workflow","title":"Build Workflow","text":"<p>Interactive workflow builder to create or edit workflow configurations.</p> <pre><code>curator build-workflow [OPTIONS] OUTPUT_FILE\n</code></pre> <p>Arguments: - <code>OUTPUT_FILE</code>: Path to save the workflow configuration (required)</p> <p>Options: - <code>--base</code>, <code>-b</code>: Base workflow to start from - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml)</p> <p>Examples: <pre><code># Create a new workflow from scratch\ncurator build-workflow my-workflow.yaml\n\n# Create a workflow based on an existing one\ncurator build-workflow new-workflow.yaml --base existing-workflow.yaml\n</code></pre></p>"},{"location":"guides/cli-reference/#edit-prompts","title":"Edit Prompts","text":"<p>Interactive editor for creating and editing prompt templates.</p> <pre><code>curator edit-prompt [OPTIONS] [PROMPT_PATH]\n</code></pre> <p>Arguments: - <code>PROMPT_PATH</code>: Path to the prompt file to edit (optional)</p> <p>Options: - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml)</p> <p>Examples: <pre><code># Launch prompt editor menu\ncurator edit-prompt\n\n# Edit a specific prompt\ncurator edit-prompt course/overview.txt\n</code></pre></p>"},{"location":"guides/cli-reference/#interactive-mode","title":"Interactive Mode","text":"<p>Launch interactive mode with a menu of common operations.</p> <pre><code>curator interactive [OPTIONS]\n</code></pre> <p>Options: - <code>--config</code>, <code>-c</code>: Path to configuration file (default: config.yaml)</p> <p>Example: <pre><code>curator interactive\n</code></pre></p>"},{"location":"guides/cli-reference/#initialize-project","title":"Initialize Project","text":"<p>Initialize a new project with example prompts and configuration.</p> <pre><code>curator init [OPTIONS] [OUTPUT_DIR]\n</code></pre> <p>Arguments: - <code>OUTPUT_DIR</code>: Directory to initialize with example prompts and configuration (default: current directory)</p> <p>Example: <pre><code># Initialize in current directory\ncurator init\n\n# Initialize in a specific directory\ncurator init my-project-dir\n</code></pre></p>"},{"location":"guides/cli-reference/#environment-variables","title":"Environment Variables","text":"<p>The Curriculum Curator CLI respects the following environment variables:</p> <ul> <li><code>OPENAI_API_KEY</code>: API key for OpenAI</li> <li><code>ANTHROPIC_API_KEY</code>: API key for Anthropic</li> <li><code>GROQ_API_KEY</code>: API key for Groq</li> <li><code>GOOGLE_API_KEY</code>: API key for Google AI (Gemini)</li> </ul> <p>You can set these in your environment or in the configuration file.</p>"},{"location":"guides/cli-reference/#error-handling","title":"Error Handling","text":"<p>When an error occurs, the CLI will: 1. Display an error message with details 2. Log additional information (if enabled) 3. Exit with a non-zero exit code</p> <p>Example error handling: <pre><code># If a workflow is not found\ncurator run non_existent_workflow\n# [bold red]Error running workflow 'non_existent_workflow':[/bold red] Workflow not found\n</code></pre></p>"},{"location":"guides/cli-reference/#logging","title":"Logging","text":"<p>By default, logs are written to the console. You can configure logging behavior in the configuration file.</p>"},{"location":"guides/cli-reference/#configuration-file","title":"Configuration File","text":"<p>The configuration file (default: <code>config.yaml</code>) defines: - LLM providers and credentials - Base paths for prompts and output - Default settings for components - Custom workflow definitions</p> <p>See the Configuration Guide for detailed information on the configuration file format.</p>"},{"location":"guides/cli-reference/#further-reading","title":"Further Reading","text":"<ul> <li>Workflow Builder Guide - How to use the interactive workflow builder</li> <li>MVP Workflow Guide - Details on using the built-in workflows</li> <li>Workflow Validation Guide - How to validate workflow configurations</li> </ul>"},{"location":"guides/interactive-mode/","title":"Interactive Mode Guide","text":"<p>The Curriculum Curator includes a fully interactive mode that provides a menu-driven interface for all operations. This guide explains how to use the interactive mode.</p>"},{"location":"guides/interactive-mode/#getting-started","title":"Getting Started","text":"<p>To launch the interactive mode, use the <code>interactive</code> command from the CLI:</p> <pre><code>curator interactive\n</code></pre> <p>This launches a menu interface that serves as a central hub for all Curriculum Curator operations.</p>"},{"location":"guides/interactive-mode/#main-menu","title":"Main Menu","text":"<p>The interactive mode presents a main menu with the following options:</p> <ol> <li>Run a Workflow - Select and run an existing workflow</li> <li>Build/Edit Workflow - Create or modify workflow configurations</li> <li>Edit Prompts - Create or edit prompt templates</li> <li>Initialize Project - Set up a new project with default configuration</li> <li>Exit - Exit interactive mode</li> </ol> <p>Each option leads to a more specific set of menus tailored to that function.</p>"},{"location":"guides/interactive-mode/#running-workflows","title":"Running Workflows","text":"<p>Selecting \"Run a Workflow\" will:</p> <ol> <li>Display a list of available workflows from both the configuration file and predefined workflows</li> <li>Let you select a workflow to run</li> <li>Prompt for any variables needed by the workflow</li> <li>Execute the workflow and display the results</li> <li>Show token usage statistics if available</li> </ol> <p>This provides a guided alternative to the <code>curator run</code> command.</p>"},{"location":"guides/interactive-mode/#buildingediting-workflows","title":"Building/Editing Workflows","text":"<p>Choosing \"Build/Edit Workflow\" will:</p> <ol> <li>Prompt for the output file path to save the workflow</li> <li>Ask if you want to start from an existing workflow</li> <li>Launch the interactive workflow builder</li> </ol> <p>This option provides the same functionality as the <code>curator build-workflow</code> command. See the Workflow Builder Guide for details on using the workflow builder.</p>"},{"location":"guides/interactive-mode/#editing-prompts","title":"Editing Prompts","text":"<p>The \"Edit Prompts\" option will:</p> <ol> <li>Ask if you want to edit a specific prompt file</li> <li>Launch the interactive prompt editor</li> </ol> <p>This provides the same functionality as the <code>curator edit-prompt</code> command. See the Prompt Editor Guide for details on using the prompt editor.</p>"},{"location":"guides/interactive-mode/#initializing-a-project","title":"Initializing a Project","text":"<p>Selecting \"Initialize Project\" will guide you through:</p> <ol> <li>Specifying a directory to initialize (defaults to the current directory)</li> <li>Creating the necessary directory structure</li> <li>Creating a default configuration file</li> <li>Optionally installing default prompt templates</li> </ol> <p>This provides an interactive alternative to the <code>curator init</code> command.</p>"},{"location":"guides/interactive-mode/#configuration","title":"Configuration","text":"<p>The interactive mode uses the specified configuration file (default: <code>config.yaml</code>) to determine:</p> <ul> <li>Available workflows</li> <li>Prompt directory location</li> <li>LLM providers and credentials</li> </ul> <p>If the configuration file is not found, some functionality will be limited, but the system will offer to initialize a new project for you.</p>"},{"location":"guides/interactive-mode/#working-without-configuration","title":"Working Without Configuration","text":"<p>If you start interactive mode without an existing configuration file, you'll still be able to:</p> <ol> <li>Initialize a new project</li> <li>Create a default configuration</li> <li>Install prompt templates</li> </ol> <p>Other operations like running workflows will prompt you to initialize the project first.</p>"},{"location":"guides/interactive-mode/#benefits-of-interactive-mode","title":"Benefits of Interactive Mode","text":"<p>Interactive mode offers several advantages over direct command usage:</p> <ol> <li>No Command Memorization - You don't need to remember specific commands or parameters</li> <li>Discoverability - All available options are presented in menus</li> <li>Guided Input - Step-by-step prompts ensure all necessary inputs are provided</li> <li>Unified Interface - One entry point for all operations</li> <li>Error Prevention - Validation and confirmation prompts prevent common mistakes</li> </ol>"},{"location":"guides/interactive-mode/#use-cases","title":"Use Cases","text":"<p>Interactive mode is especially useful for:</p> <ul> <li>New Users getting familiar with Curriculum Curator</li> <li>Occasional Users who don't remember specific commands</li> <li>Educational Settings where users may not be comfortable with command lines</li> <li>Quick Exploration of system capabilities</li> </ul> <p>Advanced users may still prefer direct command usage for scripting and automation.</p>"},{"location":"guides/interactive-mode/#next-steps","title":"Next Steps","text":"<p>After using interactive mode to set up your project, you may want to explore:</p> <ol> <li>Creating a comprehensive set of prompts for your curriculum</li> <li>Building workflows that connect multiple prompts together</li> <li>Running workflows to generate educational content</li> <li>Customizing prompt templates to suit your specific needs</li> </ol> <p>For more detailed information on specific features, see the respective guides: - Workflow Builder Guide - Prompt Editor Guide - MVP Workflow Guide</p>"},{"location":"guides/mvp-workflow/","title":"MVP Workflow Guide","text":"<p>This guide describes the minimal viable product (MVP) workflow for generating educational content with Curriculum Curator.</p>"},{"location":"guides/mvp-workflow/#overview","title":"Overview","text":"<p>The MVP workflow (<code>minimal_educational_module</code>) generates a complete educational module with the following components: - Course overview - Module outline - Lecture content - Worksheet with practice activities - Assessment with various question types - Instructor guide with teaching suggestions and answer keys</p> <p>The workflow includes validation and remediation steps to ensure content quality. Each component is output as a separate Markdown file.</p>"},{"location":"guides/mvp-workflow/#workflow-steps","title":"Workflow Steps","text":"<ol> <li>Generate Course Overview: Creates a high-level overview of the course</li> <li>Generate Module Outline: Creates a structured outline for the module</li> <li>Generate Lecture Content: Creates the main lecture content based on the outline</li> <li>Validate Lecture Content: Checks for readability and structural issues</li> <li>Remediate Lecture Content: Fixes any issues found during validation</li> <li>Generate Worksheet: Creates practice activities related to the lecture content</li> <li>Generate Assessment: Creates assessment questions to evaluate learning</li> <li>Generate Instructor Materials: Creates a guide for instructors with answer keys</li> <li>Generate Output Files: Saves all generated content to Markdown files</li> </ol>"},{"location":"guides/mvp-workflow/#configuration-based-workflow","title":"Configuration-Based Workflow","text":"<p>The MVP workflow is defined in a YAML configuration file located at <code>examples/workflows/minimal_module.yaml</code>. This approach allows for:</p> <ul> <li>Easy customization without code changes</li> <li>Reuse of common steps across different workflows</li> <li>Addition of new steps or modification of existing ones</li> <li>Simple sharing of workflow configurations</li> </ul>"},{"location":"guides/mvp-workflow/#workflow-configuration-example","title":"Workflow Configuration Example","text":"<pre><code>name: minimal_educational_module\ndescription: \"Generates a complete educational module with basic components\"\nsteps:\n  - name: course_overview\n    type: prompt\n    prompt: course/overview.txt\n    llm_model_alias: default_smart\n    output_format: raw\n    output_variable: course_overview\n\n  # Additional steps...\n\n  - name: generate_outputs\n    type: output\n    output_mapping:\n      course_overview: overview.md\n      remediated_lecture: lecture.md\n      worksheet: worksheet.md\n      assessment: assessment.md\n      instructor_materials: instructor_guide.md\n    output_dir: output/{course_slug}/{module_id}\n</code></pre>"},{"location":"guides/mvp-workflow/#running-the-workflow","title":"Running the Workflow","text":""},{"location":"guides/mvp-workflow/#using-the-cli","title":"Using the CLI","text":"<pre><code># Load workflow config from a file\ncurator run --config examples/workflows/minimal_module.yaml \\\n  --var course_title=\"Introduction to Python Programming\" \\\n  --var course_slug=\"intro-python\" \\\n  --var num_modules=4 \\\n  --var module_id=\"module1\" \\\n  --var \"learning_objectives=Understand basic Python syntax and data structures;Write simple Python programs\"\n</code></pre>"},{"location":"guides/mvp-workflow/#using-the-sample-script","title":"Using the Sample Script","text":"<p>We've provided a sample script that runs the workflow from the config file:</p> <pre><code>python examples/run_minimal_module.py\n</code></pre>"},{"location":"guides/mvp-workflow/#required-context-variables","title":"Required Context Variables","text":"<p>The workflow requires the following context variables:</p> <ul> <li><code>course_title</code>: Title of the course</li> <li><code>course_slug</code>: URL-friendly version of the course title</li> <li><code>learning_objectives</code>: List of learning objectives for the course</li> <li><code>num_modules</code>: Number of modules to generate</li> <li><code>module_id</code>: ID of the current module being generated</li> </ul>"},{"location":"guides/mvp-workflow/#output","title":"Output","text":"<p>The workflow generates the following output files in the <code>output/{course_slug}/{module_id}/</code> directory:</p> <ul> <li><code>overview.md</code>: Course overview</li> <li><code>lecture.md</code>: Lecture content</li> <li><code>worksheet.md</code>: Practice activities worksheet</li> <li><code>assessment.md</code>: Assessment questions</li> <li><code>instructor_guide.md</code>: Instructor guide with answer keys</li> </ul>"},{"location":"guides/mvp-workflow/#extending-the-workflow","title":"Extending the Workflow","text":"<p>To extend this workflow:</p> <ol> <li>Add new prompt templates in the <code>prompts/</code> directory</li> <li>Create a copy of the workflow YAML file and modify it</li> <li>Add new steps or modify existing ones in the YAML configuration</li> <li>Update the context variables to include any new required inputs</li> </ol> <p>This config-driven approach allows you to: - Create specialized workflows for different educational needs - Share workflow configurations between users - Version control your workflow definitions - Experiment with different step sequences without code changes</p>"},{"location":"guides/mvp-workflow/#creating-your-own-workflows","title":"Creating Your Own Workflows","text":"<ol> <li>Start with a copy of an existing workflow YAML file</li> <li>Add or remove steps as needed</li> <li>Configure each step with the appropriate parameters</li> <li>Test with sample inputs</li> <li>Iterate and refine as needed</li> </ol>"},{"location":"guides/mvp-workflow/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter errors:</p> <ol> <li>Check that all required context variables are provided</li> <li>Verify that your LLM API credentials are correctly configured</li> <li>Check the logs for detailed error messages</li> <li>Ensure all prompt templates have the correct metadata</li> <li>Validate your workflow YAML configuration for syntax errors</li> </ol>"},{"location":"guides/prompt-editor/","title":"Prompt Editor Guide","text":"<p>The Curriculum Curator includes an interactive prompt editor to help you create and edit prompt templates with proper front matter. This guide explains how to use the prompt editor command.</p>"},{"location":"guides/prompt-editor/#getting-started","title":"Getting Started","text":"<p>To launch the prompt editor, use the <code>edit-prompt</code> command from the CLI:</p> <pre><code># Start the prompt editor\ncurator edit-prompt\n\n# Edit a specific prompt directly\ncurator edit-prompt course/overview.txt\n</code></pre>"},{"location":"guides/prompt-editor/#using-the-interactive-interface","title":"Using the Interactive Interface","text":"<p>The prompt editor provides a menu-driven interface to guide you through creating and editing prompts:</p> <ol> <li>Main Menu - Navigate to different editor functions</li> <li>List and Edit - Browse and select existing prompts to edit</li> <li>Create New - Create a new prompt using a template</li> <li>Install Templates - Install default prompt templates for different content types</li> <li>System Editor - Your preferred text editor (via EDITOR environment variable) will be used for editing prompts</li> </ol>"},{"location":"guides/prompt-editor/#listing-and-editing-prompts","title":"Listing and Editing Prompts","text":"<p>Selecting \"List and edit existing prompts\" from the main menu shows all available prompts in the prompt directory, including metadata from the YAML front matter like title and description.</p>"},{"location":"guides/prompt-editor/#creating-new-prompts","title":"Creating New Prompts","text":"<p>When creating a new prompt, the editor offers templates for different content types:</p> <ol> <li>Course Overview</li> <li>Module Outline</li> <li>Lecture Content</li> <li>Assessment Questions</li> <li>Custom</li> </ol> <p>Each template includes appropriate front matter with: - Title - Tags - Description - Variable placeholders</p>"},{"location":"guides/prompt-editor/#installing-default-templates","title":"Installing Default Templates","text":"<p>The \"Install default templates\" option creates all standard templates in the prompt directory, organized in subdirectories by content type:</p> <ul> <li><code>course/overview.txt</code></li> <li><code>module/outline.txt</code></li> <li><code>lecture/content.txt</code></li> <li><code>assessment/questions.txt</code></li> </ul>"},{"location":"guides/prompt-editor/#front-matter-validation","title":"Front Matter Validation","text":"<p>After editing a prompt, the editor validates the front matter to ensure it includes required fields like title and description. If fields are missing, it will display a warning.</p>"},{"location":"guides/prompt-editor/#front-matter-structure","title":"Front Matter Structure","text":"<p>Prompts in Curriculum Curator use YAML front matter to provide metadata. A typical front matter section looks like:</p> <pre><code>---\ntitle: Course Overview\ntags: [course, overview]\ndescription: Generate a course overview with objectives, topics, and prerequisites\nvariables:\n  - course_title\n  - target_audience\n---\n</code></pre> <p>The front matter provides: - title: Title of the prompt (required) - tags: Tags for categorizing prompts - description: Brief description of what the prompt does (required) - variables: List of variables expected in the prompt</p>"},{"location":"guides/prompt-editor/#default-prompt-structure","title":"Default Prompt Structure","text":"<p>Each prompt follows a standard structure:</p> <ol> <li>YAML Front Matter - Metadata about the prompt</li> <li>System Message - Instructions for the LLM about its role (e.g., \"You are an expert curriculum designer.\")</li> <li>Task Description - Clear description of what to generate</li> <li>Outline/Requirements - Structured list of what to include</li> <li>Format Instructions - How to format the output (usually markdown)</li> </ol>"},{"location":"guides/prompt-editor/#using-variables-in-prompts","title":"Using Variables in Prompts","text":"<p>Variables are placeholders in prompts that get replaced with actual values when the workflow runs. They use double curly braces:</p> <pre><code>You are an expert curriculum designer. Your task is to create a comprehensive overview for a course titled \"{{course_title}}\".\n\nThe target audience for this course is {{target_audience}}.\n</code></pre>"},{"location":"guides/prompt-editor/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Titles - Make prompt titles clear and specific</li> <li>Add Comprehensive Tags - Tags help with filtering and organization</li> <li>List All Variables - Include all variables in the front matter</li> <li>Structure Prompts Consistently - Keep a consistent format across prompts</li> <li>Include Format Instructions - Always specify how output should be formatted</li> </ol>"},{"location":"guides/prompt-editor/#example-workflow","title":"Example Workflow","text":"<p>Here's a typical workflow for creating a new prompt:</p> <ol> <li>Launch the prompt editor: <code>curator edit-prompt</code></li> <li>Select \"Create a new prompt\" from the menu</li> <li>Choose a template type (e.g., \"course/overview\")</li> <li>Specify the prompt file path (e.g., \"course/my-new-course.txt\")</li> <li>Edit the prompt in your system text editor</li> <li>Save and close the editor</li> <li>Review the front matter validation results</li> </ol>"},{"location":"guides/prompt-editor/#using-the-prompt-editor-with-workflow-builder","title":"Using the Prompt Editor with Workflow Builder","text":"<p>The prompt editor and workflow builder work together seamlessly:</p> <ol> <li>Create prompts with the editor</li> <li>Reference them in workflow configurations via the workflow builder</li> <li>Run the workflow using the CLI</li> </ol>"},{"location":"guides/prompt-editor/#next-steps","title":"Next Steps","text":"<p>After creating prompts with the editor, you can:</p> <ol> <li>Build a workflow that uses your prompts</li> <li>Test your prompts with different variables</li> <li>Create additional prompts for other content types</li> <li>Organize your prompts into a comprehensive curriculum structure</li> </ol> <p>For a complete guide to building workflows, see the Workflow Builder Guide.</p>"},{"location":"guides/pypi-publishing/","title":"Publishing to PyPI","text":"<p>This guide explains how to build and publish the Curriculum Curator package to PyPI.</p>"},{"location":"guides/pypi-publishing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Create accounts on PyPI and TestPyPI</li> <li>Generate API tokens for both PyPI and TestPyPI</li> <li>Have the following packages installed:    <pre><code>pip install build twine\n</code></pre></li> </ol>"},{"location":"guides/pypi-publishing/#setup-pypi-credentials","title":"Setup PyPI Credentials","text":"<ol> <li> <p>Copy the template file to your home directory:    <pre><code>cp .pypirc.template ~/.pypirc\n</code></pre></p> </li> <li> <p>Edit the file with your tokens:    <pre><code>nano ~/.pypirc\n</code></pre></p> </li> <li> <p>Replace the token placeholders with your actual tokens</p> </li> </ol>"},{"location":"guides/pypi-publishing/#building-the-package","title":"Building the Package","text":"<p>From the project root directory, run:</p> <pre><code>python -m build\n</code></pre> <p>This will create: - A source distribution (<code>.tar.gz</code> file) in the <code>dist/</code> directory - A wheel (<code>.whl</code> file) in the <code>dist/</code> directory</p>"},{"location":"guides/pypi-publishing/#uploading-to-testpypi","title":"Uploading to TestPyPI","text":"<p>Before uploading to the main PyPI repository, you should test the package on TestPyPI:</p> <pre><code>twine upload --repository testpypi dist/*\n</code></pre>"},{"location":"guides/pypi-publishing/#installing-from-testpypi","title":"Installing from TestPyPI","text":"<p>To verify the package works when installed from TestPyPI:</p> <pre><code>pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ curriculum-curator\n</code></pre> <p>Note: The <code>--extra-index-url</code> option is needed because TestPyPI doesn't have all the dependencies.</p>"},{"location":"guides/pypi-publishing/#uploading-to-pypi","title":"Uploading to PyPI","text":"<p>Once you've verified the package works properly from TestPyPI, you can upload it to the main PyPI repository:</p> <pre><code>twine upload dist/*\n</code></pre>"},{"location":"guides/pypi-publishing/#version-management","title":"Version Management","text":"<ol> <li>Update the version number in <code>pyproject.toml</code> before each release</li> <li>Follow semantic versioning: MAJOR.MINOR.PATCH</li> <li>Update the CHANGELOG.md file with the changes in the new release</li> <li>Create a git tag for each release:    <pre><code>git tag v0.2.0\ngit push origin v0.2.0\n</code></pre></li> </ol>"},{"location":"guides/pypi-publishing/#publishing-version-020","title":"Publishing Version 0.2.0","text":"<p>To publish version 0.2.0 with the new workflow builder:</p> <ol> <li> <p>Clean previous builds:    <pre><code>rm -rf dist/ build/ *.egg-info/\n</code></pre></p> </li> <li> <p>Build the package:    <pre><code>python -m build\n</code></pre></p> </li> <li> <p>Upload to TestPyPI:    <pre><code>twine upload --repository testpypi dist/*\n</code></pre></p> </li> <li> <p>Test the installation from TestPyPI:    <pre><code>pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ curriculum-curator==0.2.0\n</code></pre></p> </li> <li> <p>Verify the workflow builder works:    <pre><code>curator list-validators\ncurator list-remediators\ncurator build-workflow --help\n</code></pre></p> </li> <li> <p>If everything works correctly, upload to PyPI:    <pre><code>twine upload dist/*\n</code></pre></p> </li> </ol>"},{"location":"guides/workflow-builder/","title":"Workflow Builder Guide","text":"<p>The Curriculum Curator includes an interactive workflow builder to help you create and edit workflow configurations without directly editing YAML files. This guide explains how to use the workflow builder command.</p>"},{"location":"guides/workflow-builder/#getting-started","title":"Getting Started","text":"<p>To launch the workflow builder, use the <code>build-workflow</code> command from the CLI:</p> <pre><code># Start with a fresh workflow\ncurator build-workflow my-workflow.yaml\n\n# Start with an existing workflow as a base\ncurator build-workflow my-workflow.yaml --base existing-workflow.yaml\n</code></pre>"},{"location":"guides/workflow-builder/#using-the-interactive-interface","title":"Using the Interactive Interface","text":"<p>The workflow builder provides a menu-driven interface to guide you through creating your workflow configuration:</p> <ol> <li>Main Menu - Navigate to different builder functions</li> <li>Workflow Metadata - Set name and description</li> <li>Default Settings - Configure defaults for all steps</li> <li>Steps Management - Add, edit, remove, and reorder workflow steps</li> <li>Validation - Validate your workflow before saving</li> <li>Save - Write your workflow to a file</li> </ol>"},{"location":"guides/workflow-builder/#setting-workflow-metadata","title":"Setting Workflow Metadata","text":"<p>Every workflow requires a name and description. You can set these by choosing option 1 from the main menu.</p>"},{"location":"guides/workflow-builder/#configuring-default-settings","title":"Configuring Default Settings","text":"<p>Default settings apply to all steps in your workflow unless overridden at the step level. Common defaults include:</p> <ul> <li><code>llm_model_alias</code> - Default LLM model to use</li> <li><code>output_format</code> - Default format for generated content</li> </ul>"},{"location":"guides/workflow-builder/#adding-steps","title":"Adding Steps","text":"<p>The workflow builder supports the following step types:</p> <ol> <li>Prompt Steps - Generate content using an LLM and a prompt template</li> <li>Validation Steps - Check content quality using validators</li> <li>Remediation Steps - Fix issues in content</li> <li>Output Steps - Save content to files</li> </ol> <p>Each step type has its own guided configuration process.</p>"},{"location":"guides/workflow-builder/#prompt-steps","title":"Prompt Steps","text":"<p>Prompt steps generate content using an LLM. When adding a prompt step, you'll need to:</p> <ol> <li>Provide a unique name</li> <li>Select a prompt template from available prompts or enter a custom path</li> <li>Specify an output variable name to store generated content</li> <li>Choose an output format (raw, json, list, html)</li> <li>Optionally specify an LLM model alias</li> </ol>"},{"location":"guides/workflow-builder/#validation-steps","title":"Validation Steps","text":"<p>Validation steps check content quality. When adding a validation step:</p> <ol> <li>Provide a unique name</li> <li>Specify the content variable to validate</li> <li>Specify an output variable for validation issues</li> <li>Select validators to apply from the available list</li> </ol> <p>To see available validators, use:</p> <pre><code>curator list-validators\n</code></pre>"},{"location":"guides/workflow-builder/#remediation-steps","title":"Remediation Steps","text":"<p>Remediation steps fix issues in content. When adding a remediation step:</p> <ol> <li>Provide a unique name</li> <li>Specify the content variable to remediate</li> <li>Specify the variable containing validation issues</li> <li>Specify an output variable for remediated content</li> <li>Optionally specify a variable for remediation actions</li> </ol> <p>To see available remediators, use:</p> <pre><code>curator list-remediators\n</code></pre>"},{"location":"guides/workflow-builder/#output-steps","title":"Output Steps","text":"<p>Output steps save content to files. When adding an output step:</p> <ol> <li>Provide a unique name</li> <li>Specify an output directory path</li> <li>Define mappings from variables to output filenames</li> <li>Optionally specify output formats</li> </ol>"},{"location":"guides/workflow-builder/#editing-and-reordering-steps","title":"Editing and Reordering Steps","text":"<p>You can edit existing steps, remove steps, or change their order using the respective options in the main menu.</p>"},{"location":"guides/workflow-builder/#validating-and-saving","title":"Validating and Saving","text":"<p>Before saving, the workflow builder validates your configuration against the schema. If validation passes, your workflow is saved to the specified file. If there are issues, they will be displayed so you can fix them.</p>"},{"location":"guides/workflow-builder/#example-workflow","title":"Example Workflow","text":"<p>Here's an example of a simple workflow you might create with the builder:</p> <ol> <li>Prompt Step - Generate course overview content</li> <li>Name: <code>generate_overview</code></li> <li>Prompt: <code>course/overview.txt</code></li> <li>Output Variable: <code>course_overview</code></li> <li> <p>Format: <code>raw</code></p> </li> <li> <p>Validation Step - Check content quality</p> </li> <li>Name: <code>validate_overview</code></li> <li>Content Variable: <code>course_overview</code></li> <li>Output Variable: <code>validation_issues</code></li> <li> <p>Validators: <code>readability</code>, <code>structure</code></p> </li> <li> <p>Remediation Step - Fix any issues</p> </li> <li>Name: <code>fix_overview</code></li> <li>Content Variable: <code>course_overview</code></li> <li>Issues Variable: <code>validation_issues</code></li> <li> <p>Output Variable: <code>fixed_overview</code></p> </li> <li> <p>Output Step - Save the content</p> </li> <li>Name: <code>save_overview</code></li> <li>Output Directory: <code>output/</code></li> <li>Output Mapping: <code>fixed_overview</code> \u2192 <code>course_overview.md</code></li> </ol>"},{"location":"guides/workflow-builder/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Names - Give your steps clear, descriptive names.</li> <li>Variable Naming Conventions - Establish a convention for variable names (e.g., <code>original_content</code>, <code>validated_content</code>, etc.).</li> <li>Review Available Components - Use the <code>list-prompts</code>, <code>list-validators</code>, and <code>list-remediators</code> commands to see what's available.</li> <li>Start Simple - Begin with a minimal workflow and add complexity as needed.</li> <li>Test Incrementally - Save and test your workflow after adding each major step.</li> </ol>"},{"location":"guides/workflow-builder/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with the workflow builder:</p> <ul> <li>Ensure your configuration file is properly set up.</li> <li>Check that prompt templates, validators, and remediators are available in the system.</li> <li>Review the validation errors if your workflow fails validation.</li> <li>For command syntax help, use <code>curator build-workflow --help</code>.</li> </ul>"},{"location":"guides/workflow-builder/#next-steps","title":"Next Steps","text":"<p>After creating a workflow with the builder, you can:</p> <ol> <li>Run the workflow with <code>curator run &lt;workflow-name&gt;</code></li> <li>Further customize it manually if needed</li> <li>Use it as a base for more complex workflows</li> </ol>"},{"location":"guides/workflow-validation/","title":"Workflow Configuration Validation","text":"<p>Curriculum Curator provides a robust validation system for workflow configurations to catch errors early in the development process.</p>"},{"location":"guides/workflow-validation/#overview","title":"Overview","text":"<p>The validation system uses Pydantic models to enforce schema validation for workflow configurations. This ensures that:</p> <ol> <li>All required fields are present</li> <li>Field values have the correct types</li> <li>Step-specific fields are used correctly</li> <li>Defaults are applied properly</li> <li>Detailed error messages are provided when validation fails</li> </ol>"},{"location":"guides/workflow-validation/#benefits","title":"Benefits","text":"<p>Using the validation system provides several benefits:</p> <ol> <li>Early Error Detection: Configuration errors are caught before execution begins</li> <li>Clear Error Messages: Detailed error messages identify exactly what's wrong</li> <li>Better Developer Experience: Autocomplete and type hints help when writing configurations</li> <li>Safer Production Deployments: Validated configurations are less likely to fail at runtime</li> <li>Reduced LLM Costs: Catching errors early prevents unnecessary LLM calls for invalid workflows</li> </ol>"},{"location":"guides/workflow-validation/#validating-workflows","title":"Validating Workflows","text":""},{"location":"guides/workflow-validation/#using-the-validation-tool","title":"Using the Validation Tool","text":"<p>Curriculum Curator includes a validation tool to check workflow configurations:</p> <pre><code># Validate a single workflow file\npython -m curriculum_curator.tools.validate_workflow examples/workflows/minimal_module.yaml\n\n# Validate all discovered workflows\npython -m curriculum_curator.tools.validate_workflow --all\n</code></pre>"},{"location":"guides/workflow-validation/#programmatic-validation","title":"Programmatic Validation","text":"<p>You can also validate workflows programmatically:</p> <pre><code>from curriculum_curator.workflow.workflows import load_workflow_config\n\n# Load and validate a workflow\nworkflow_config = load_workflow_config(\"examples/workflows/minimal_module.yaml\")\n\nif workflow_config:\n    print(f\"Workflow '{workflow_config.name}' is valid\")\nelse:\n    print(\"Workflow validation failed\")\n</code></pre>"},{"location":"guides/workflow-validation/#configuration-schema","title":"Configuration Schema","text":"<p>The workflow configuration schema is defined using Pydantic models:</p>"},{"location":"guides/workflow-validation/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>name: \"workflow_name\"  # Required: Unique identifier for the workflow\ndescription: \"Description\"  # Required: Human-readable description of the workflow\n\ndefaults:  # Optional: Defaults to apply to all steps unless overridden\n  llm_model_alias: \"default_smart\"  # Default LLM model for prompt steps\n  output_format: \"raw\"  # Default output format for prompt steps\n  validators: [\"readability\", \"structure\"]  # Default validators for validation steps\n\nsteps:  # Required: List of steps to execute\n  - name: \"step_name\"  # Each step must have a name and type\n    type: \"prompt\"  # Type determines what other fields are required\n    # ...additional fields based on step type\n</code></pre>"},{"location":"guides/workflow-validation/#step-types-and-required-fields","title":"Step Types and Required Fields","text":""},{"location":"guides/workflow-validation/#prompt-step","title":"Prompt Step","text":"<pre><code>- name: \"generate_content\"\n  type: \"prompt\"\n  prompt: \"path/to/prompt.txt\"  # Required: Path to prompt template\n  output_variable: \"result_variable\"  # Required: Where to store result\n  llm_model_alias: \"default_smart\"  # Optional: Override default\n  output_format: \"raw\"  # Optional: Override default (raw, json, list, html)\n  transformation_rules: {}  # Optional: Additional transformation rules\n</code></pre>"},{"location":"guides/workflow-validation/#validation-step","title":"Validation Step","text":"<pre><code>- name: \"validate_content\"\n  type: \"validation\"\n  content_variable: \"content_to_validate\"  # Required: Content to validate\n  output_variable: \"validation_issues\"  # Required: Where to store issues\n  validators: [\"readability\", \"structure\"]  # Required: Validators to apply\n  validation_config:  # Optional: Additional validator configuration\n    similarity:\n      threshold: 0.8\n</code></pre>"},{"location":"guides/workflow-validation/#remediation-step","title":"Remediation Step","text":"<pre><code>- name: \"fix_issues\"\n  type: \"remediation\"\n  content_variable: \"content_to_fix\"  # Required: Content to fix\n  issues_variable: \"validation_issues\"  # Required: Issues to fix\n  output_variable: \"fixed_content\"  # Required: Where to store fixed content\n  actions_variable: \"remediation_actions\"  # Optional: Store remediation actions\n  remediation_config: {}  # Optional: Additional remediator configuration\n</code></pre>"},{"location":"guides/workflow-validation/#output-step","title":"Output Step","text":"<pre><code>- name: \"generate_files\"\n  type: \"output\"\n  output_mapping:  # Required: Maps variables to file names\n    variable_name: \"output_file.md\"\n  output_dir: \"output/path\"  # Required: Output directory\n  output_variable: \"output_files\"  # Optional: Store output file paths\n</code></pre>"},{"location":"guides/workflow-validation/#common-validation-errors","title":"Common Validation Errors","text":"<p>Here are some common validation errors and how to fix them:</p>"},{"location":"guides/workflow-validation/#missing-required-fields","title":"Missing Required Fields","text":"<pre><code>validation error: field required (type=value_error.missing)\n</code></pre> <p>This error means a required field is missing. Check the schema to identify which field is required for the step type.</p>"},{"location":"guides/workflow-validation/#type-errors","title":"Type Errors","text":"<pre><code>validation error: value is not a valid dict (type=type_error.dict)\n</code></pre> <p>This error means a field has the wrong type. Make sure your field values match the expected types in the schema.</p>"},{"location":"guides/workflow-validation/#invalid-enum-values","title":"Invalid Enum Values","text":"<pre><code>validation error: value is not a valid enumeration member (type=type_error.enum)\n</code></pre> <p>This error means you're using an invalid value for a field with limited options (like output_format or step type).</p>"},{"location":"guides/workflow-validation/#unknown-fields","title":"Unknown Fields","text":"<pre><code>validation error: extra fields not permitted (type=value_error.extra)\n</code></pre> <p>This error means you're using fields that aren't defined in the schema. Check for typos or remove the unknown fields.</p>"},{"location":"guides/workflow-validation/#extension-and-customization","title":"Extension and Customization","text":"<p>The validation system is designed to be extended as new step types are added to the workflow engine. When adding a new step type:</p> <ol> <li>Define a new Pydantic model for the step type in <code>models.py</code></li> <li>Add the new model to the <code>StepConfig</code> union type</li> <li>Update the <code>parse_steps</code> method to handle the new step type</li> <li>Update the workflow engine to create and execute the new step type</li> </ol> <p>This ensures that validation remains robust as the system evolves.</p>"}]}